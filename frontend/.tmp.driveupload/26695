// ============================================
// NOTIFICATION CONTEXT - FIXED WITH SETTINGS CHECK
// Global state management for notifications
// Implements HTTP Polling for real-time updates
// ============================================
// Developer: Suvadip Panja
// Updated: January 29, 2026
// File: frontend/src/context/notifications/NotificationContext.jsx
// âœ… FIXED: Using correct settingsService.fetchSettings() method
// PRODUCTION READY: Now respects notification settings
// ============================================

import { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import api from '../../services/api';
import settingsService from '../../services/settingsService';

// ============================================
// CREATE CONTEXT
// ============================================
const NotificationContext = createContext();

// ============================================
// CUSTOM HOOK: useNotification
// ============================================
export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within NotificationProvider');
  }
  return context;
};

// ============================================
// NOTIFICATION PROVIDER COMPONENT
// ============================================
export const NotificationProvider = ({ children }) => {
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);

  // ============================================
  // POLLING CONFIGURATION
  // ============================================
  const POLL_INTERVAL = 20000; // 20 seconds
  const lastPollTimeRef = useRef(0);
  const pollingIntervalRef = useRef(null);
  const isPollingRef = useRef(false);

  // ============================================
  // âœ… FIXED: CHECK IF NOTIFICATIONS ARE ENABLED
  // Using fetchSettings() instead of getAllSettings()
  // ============================================
  const checkNotificationSettings = useCallback(async () => {
    try {
      // âœ… FIXED: Use fetchSettings() - the correct method name
      const settings = await settingsService.fetchSettings();
      
      if (settings && settings.notification) {
        const enabled = settings.notification.notification_enabled?.value === 'true' ||
                       settings.notification.notification_enabled?.value === true;
        
        setNotificationsEnabled(enabled);
        
        console.log('ðŸ”” Notification settings loaded:', {
          enabled,
          raw: settings.notification.notification_enabled?.value
        });
        
        return enabled;
      }
      
      // Default to enabled if settings not found
      setNotificationsEnabled(true);
      return true;
      
    } catch (error) {
      console.error('âŒ Error checking notification settings:', error);
      // Default to enabled on error
      setNotificationsEnabled(true);
      return true;
    }
  }, []);

  // ============================================
  // FETCH NOTIFICATIONS
  // ============================================
  const fetchNotifications = useCallback(async (page = 1, limit = 20) => {
    try {
      setLoading(true);
      setError(null);

      const response = await api.get('/notifications', {
        params: { page, limit },
      });

      if (response.data.success) {
        const fetchedNotifications = response.data.data.notifications || [];
        setNotifications(fetchedNotifications);
        return fetchedNotifications;
      }
      return [];
    } catch (err) {
      console.error('âŒ Error fetching notifications:', err);
      setError('Failed to load notifications');
      return [];
    } finally {
      setLoading(false);
    }
  }, []);

  // ============================================
  // FETCH UNREAD COUNT
  // ============================================
  const fetchUnreadCount = useCallback(async () => {
    // Skip if notifications are disabled
    if (!notificationsEnabled) {
      return 0;
    }

    try {
      lastPollTimeRef.current = Date.now();
      const response = await api.get('/notifications/unread-count');

      if (response.data.success) {
        const count = response.data.data.count || 0;
        setUnreadCount(count);
        return count;
      }
      return 0;
    } catch (err) {
      // Only log error if it's not a network error (to avoid spam)
      if (err.response) {
        console.error('âŒ Error fetching unread count:', err);
      }
      return 0;
    }
  }, [notificationsEnabled]);

  // ============================================
  // MARK NOTIFICATION AS READ
  // ============================================
  const markAsRead = useCallback(async (notificationId) => {
    try {
      const response = await api.put(`/notifications/${notificationId}/read`);

      if (response.data.success) {
        // Update local state
        setNotifications((prev) =>
          prev.map((notif) =>
            notif.notification_id === notificationId
              ? { ...notif, is_read: true }
              : notif
          )
        );

        // Update unread count
        setUnreadCount((prev) => Math.max(0, prev - 1));
        
        return true;
      }
      return false;
    } catch (err) {
      console.error('âŒ Error marking notification as read:', err);
      return false;
    }
  }, []);

  // ============================================
  // MARK ALL AS READ
  // ============================================
  const markAllAsRead = useCallback(async () => {
    try {
      const response = await api.put('/notifications/mark-all-read');

      if (response.data.success) {
        // Update local state
        setNotifications((prev) =>
          prev.map((notif) => ({ ...notif, is_read: true }))
        );

        // Reset unread count
        setUnreadCount(0);
        
        return true;
      }
      return false;
    } catch (err) {
      console.error('âŒ Error marking all as read:', err);
      return false;
    }
  }, []);

  // ============================================
  // DELETE NOTIFICATION
  // ============================================
  const deleteNotification = useCallback(async (notificationId) => {
    try {
      const response = await api.delete(`/notifications/${notificationId}`);

      if (response.data.success) {
        // Remove from local state
        setNotifications((prev) =>
          prev.filter((notif) => notif.notification_id !== notificationId)
        );

        // Update unread count if needed
        const notif = notifications.find((n) => n.notification_id === notificationId);
        if (notif && !notif.is_read) {
          setUnreadCount((prev) => Math.max(0, prev - 1));
        }
        
        return true;
      }
      return false;
    } catch (err) {
      console.error('âŒ Error deleting notification:', err);
      return false;
    }
  }, [notifications]);

  // ============================================
  // CLEAR READ NOTIFICATIONS
  // ============================================
  const clearReadNotifications = useCallback(async () => {
    try {
      const response = await api.delete('/notifications/clear-read');

      if (response.data.success) {
        // Remove read notifications from local state
        setNotifications((prev) => prev.filter((notif) => !notif.is_read));
        
        return true;
      }
      return false;
    } catch (err) {
      console.error('âŒ Error clearing read notifications:', err);
      return false;
    }
  }, []);

  // ============================================
  // REFRESH NOTIFICATIONS
  // ============================================
  const refreshNotifications = useCallback(async () => {
    await checkNotificationSettings();
    await Promise.all([
      fetchUnreadCount(),
      fetchNotifications(),
    ]);
  }, [checkNotificationSettings, fetchUnreadCount, fetchNotifications]);

  // ============================================
  // POLLING LOGIC
  // ============================================
  useEffect(() => {
    // Check if user is authenticated
    const token = localStorage.getItem('token');
    if (!token) {
      return;
    }

    // Check settings first
    const initPolling = async () => {
      const enabled = await checkNotificationSettings();
      
      if (!enabled) {
        console.log('ðŸ”• Notifications disabled, skipping polling');
        return;
      }

      // Initial fetch
      fetchUnreadCount();

      // Start polling
      if (!isPollingRef.current) {
        isPollingRef.current = true;
        console.log('âœ… Notification polling started (every 20s)');

        pollingIntervalRef.current = setInterval(() => {
          if (document.visibilityState === 'visible' && notificationsEnabled) {
            fetchUnreadCount();
          }
        }, POLL_INTERVAL);
      }
    };

    initPolling();

    // Cleanup
    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
        pollingIntervalRef.current = null;
        isPollingRef.current = false;
        console.log('âŒ Notification polling stopped');
      }
    };
  }, [checkNotificationSettings, fetchUnreadCount, notificationsEnabled]);

  // ============================================
  // HANDLE VISIBILITY CHANGE
  // ============================================
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible' && notificationsEnabled) {
        const now = Date.now();
        const timeSinceLastPoll = now - lastPollTimeRef.current;
        
        // Only fetch if it's been more than 5 seconds
        if (timeSinceLastPoll > 5000) {
          fetchUnreadCount();
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [fetchUnreadCount, notificationsEnabled]);

  // ============================================
  // CONTEXT VALUE
  // ============================================
  const value = {
    // State
    notifications,
    unreadCount,
    loading,
    error,
    isPolling: isPollingRef.current,
    notificationsEnabled,

    // Functions
    fetchNotifications,
    fetchUnreadCount,
    markAsRead,
    markAllAsRead,
    deleteNotification,
    clearReadNotifications,
    refreshNotifications,
    checkNotificationSettings,
  };

  // ============================================
  // RENDER PROVIDER
  // ============================================
  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

// ============================================
// EXPORT
// ============================================
export default NotificationContext;