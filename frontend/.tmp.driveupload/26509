/**
 * ============================================
 * ALL NOTIFICATIONS PAGE - MODERNIZED
 * ============================================
 * Production-Ready Notifications Management
 * 
 * FEATURES:
 * - Modern glassmorphism UI design
 * - Toast notifications for all actions
 * - Memoized components for performance
 * - Accessibility compliant (ARIA)
 * - Responsive design
 * - Smooth animations
 * - Bulk operations
 * - Search & Filter
 * 
 * Developer: Suvadip Panja
 * Company: Digitide
 * Version: 2.0.0
 * Updated: February 2026
 * FILE: frontend/src/pages/notifications/AllNotifications.jsx
 * ============================================
 */

import { useState, useEffect, useCallback, useMemo, memo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { useNotification } from '../../context/notifications/NotificationContext';
import { useToast } from '../../context/ToastContext';
import {
  Bell,
  BellOff,
  CheckCheck,
  Trash2,
  Eye,
  EyeOff,
  RefreshCw,
  Search,
  Calendar,
  Ticket,
  AlertCircle,
  CheckCircle,
  XCircle,
  Clock,
  MessageSquare,
  UserPlus,
  AlertTriangle,
  ArrowUp,
  Filter,
  ChevronLeft,
  ChevronRight,
  Inbox,
  MailOpen,
  Mail,
  Sparkles
} from 'lucide-react';
import '../../styles/AllNotifications.css';

// ============================================
// NOTIFICATION TYPE CONFIGURATION
// ============================================
const NOTIFICATION_TYPES = {
  TICKET_CREATED: {
    icon: Ticket,
    color: '#3b82f6',
    bgColor: 'rgba(59, 130, 246, 0.1)',
    label: 'New Ticket'
  },
  TICKET_ASSIGNED: {
    icon: UserPlus,
    color: '#8b5cf6',
    bgColor: 'rgba(139, 92, 246, 0.1)',
    label: 'Assigned'
  },
  TICKET_UPDATED: {
    icon: RefreshCw,
    color: '#f59e0b',
    bgColor: 'rgba(245, 158, 11, 0.1)',
    label: 'Updated'
  },
  TICKET_COMMENTED: {
    icon: MessageSquare,
    color: '#10b981',
    bgColor: 'rgba(16, 185, 129, 0.1)',
    label: 'Comment'
  },
  TICKET_RESOLVED: {
    icon: CheckCircle,
    color: '#22c55e',
    bgColor: 'rgba(34, 197, 94, 0.1)',
    label: 'Resolved'
  },
  TICKET_CLOSED: {
    icon: XCircle,
    color: '#64748b',
    bgColor: 'rgba(100, 116, 139, 0.1)',
    label: 'Closed'
  },
  TICKET_ESCALATED: {
    icon: ArrowUp,
    color: '#ef4444',
    bgColor: 'rgba(239, 68, 68, 0.1)',
    label: 'Escalated'
  },
  SLA_WARNING: {
    icon: AlertTriangle,
    color: '#f59e0b',
    bgColor: 'rgba(245, 158, 11, 0.1)',
    label: 'SLA Warning'
  },
  SLA_BREACH: {
    icon: AlertCircle,
    color: '#ef4444',
    bgColor: 'rgba(239, 68, 68, 0.1)',
    label: 'SLA Breach'
  },
  DEFAULT: {
    icon: Bell,
    color: '#6366f1',
    bgColor: 'rgba(99, 102, 241, 0.1)',
    label: 'Notification'
  }
};

// ============================================
// STATS CARD COMPONENT (Memoized)
// ============================================
const StatsCard = memo(({ icon: Icon, label, value, color, bgColor, onClick, isActive }) => (
  <button
    type="button"
    className={`notif-stats-card ${isActive ? 'active' : ''}`}
    onClick={onClick}
    style={{ '--card-color': color, '--card-bg': bgColor }}
  >
    <div className="notif-stats-icon">
      <Icon size={20} />
    </div>
    <div className="notif-stats-info">
      <span className="notif-stats-value">{value}</span>
      <span className="notif-stats-label">{label}</span>
    </div>
  </button>
));

StatsCard.displayName = 'StatsCard';

// ============================================
// NOTIFICATION ITEM COMPONENT (Memoized)
// ============================================
const NotificationItem = memo(({ 
  notification, 
  isSelected, 
  onSelect, 
  onClick, 
  onMarkRead, 
  onDelete,
  canDelete,
  formatTime 
}) => {
  const typeConfig = NOTIFICATION_TYPES[notification.notification_type] || NOTIFICATION_TYPES.DEFAULT;
  const Icon = typeConfig.icon;

  return (
    <div
      className={`notif-item ${!notification.is_read ? 'unread' : ''} ${isSelected ? 'selected' : ''}`}
      onClick={() => onClick(notification)}
      role="button"
      tabIndex={0}
      aria-label={`${notification.title} - ${notification.is_read ? 'Read' : 'Unread'}`}
      onKeyDown={(e) => e.key === 'Enter' && onClick(notification)}
    >
      {/* Selection Checkbox */}
      <div className="notif-item-checkbox">
        <input
          type="checkbox"
          checked={isSelected}
          onChange={(e) => {
            e.stopPropagation();
            onSelect(notification.notification_id);
          }}
          onClick={(e) => e.stopPropagation()}
          aria-label={`Select notification: ${notification.title}`}
        />
      </div>

      {/* Icon */}
      <div 
        className="notif-item-icon"
        style={{ 
          backgroundColor: typeConfig.bgColor,
          color: typeConfig.color
        }}
      >
        <Icon size={20} />
      </div>

      {/* Content */}
      <div className="notif-item-content">
        <div className="notif-item-header">
          <h4 className="notif-item-title">{notification.title}</h4>
          <div className="notif-item-meta">
            <span 
              className="notif-item-type-badge"
              style={{ 
                backgroundColor: typeConfig.bgColor,
                color: typeConfig.color
              }}
            >
              {typeConfig.label}
            </span>
            <span className="notif-item-time">
              <Clock size={12} />
              {formatTime(notification.created_at)}
            </span>
          </div>
        </div>

        <p className="notif-item-message">{notification.message}</p>

        {notification.ticket_number && (
          <div className="notif-item-ticket">
            <Ticket size={14} />
            <span>{notification.ticket_number}</span>
          </div>
        )}
      </div>

      {/* Actions */}
      <div className="notif-item-actions">
        {!notification.is_read && (
          <button
            type="button"
            className="notif-action-btn mark-read"
            onClick={(e) => {
              e.stopPropagation();
              onMarkRead(notification.notification_id);
            }}
            title="Mark as read"
            aria-label="Mark as read"
          >
            <Eye size={16} />
          </button>
        )}
        {canDelete && (
          <button
            type="button"
            className="notif-action-btn delete"
            onClick={(e) => {
              e.stopPropagation();
              onDelete(notification.notification_id);
            }}
            title="Delete notification"
            aria-label="Delete notification"
          >
            <Trash2 size={16} />
          </button>
        )}
      </div>

      {/* Unread Indicator */}
      {!notification.is_read && (
        <div className="notif-unread-dot" aria-hidden="true" />
      )}
    </div>
  );
});

NotificationItem.displayName = 'NotificationItem';

// ============================================
// EMPTY STATE COMPONENT (Memoized)
// ============================================
const EmptyState = memo(({ filter, searchQuery }) => (
  <div className="notif-empty-state">
    <div className="notif-empty-icon">
      {filter === 'unread' ? <MailOpen size={64} /> : <Inbox size={64} />}
    </div>
    <h3 className="notif-empty-title">
      {searchQuery 
        ? 'No matching notifications'
        : filter === 'unread'
          ? 'All caught up!'
          : 'No notifications yet'
      }
    </h3>
    <p className="notif-empty-message">
      {searchQuery 
        ? 'Try adjusting your search terms'
        : filter === 'unread'
          ? 'You have no unread notifications'
          : 'Notifications will appear here when you receive them'
      }
    </p>
  </div>
));

EmptyState.displayName = 'EmptyState';

// ============================================
// LOADING STATE COMPONENT (Memoized)
// ============================================
const LoadingState = memo(() => (
  <div className="notif-loading-state">
    <div className="notif-loading-spinner">
      <RefreshCw size={32} className="spinning" />
    </div>
    <p>Loading notifications...</p>
  </div>
));

LoadingState.displayName = 'LoadingState';

// ============================================
// MAIN COMPONENT
// ============================================
const AllNotifications = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { showToast } = useToast();
  
  // ============================================
  // NOTIFICATION CONTEXT
  // ============================================
  const {
    notifications,
    unreadCount,
    loading,
    fetchNotifications,
    markAsRead,
    markAllAsRead,
    deleteNotification,
    clearReadNotifications,
  } = useNotification();

  // ============================================
  // LOCAL STATE
  // ============================================
  const [filter, setFilter] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [totalRecords, setTotalRecords] = useState(0);
  const [selectedNotifications, setSelectedNotifications] = useState([]);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const ITEMS_PER_PAGE = 20;

  // ============================================
  // PERMISSION CHECK
  // ============================================
  const canDelete = useMemo(() => 
    user?.role_name === 'Admin' || 
    user?.permissions?.can_manage_system,
    [user]
  );

  // ============================================
  // LOAD NOTIFICATIONS
  // ============================================
  const loadNotifications = useCallback(async () => {
    try {
      const unreadOnly = filter === 'unread';
      const result = await fetchNotifications(currentPage, ITEMS_PER_PAGE, unreadOnly);
      
      if (result && result.pagination) {
        setTotalPages(result.pagination.total_pages || 1);
        setTotalRecords(result.pagination.total_records || 0);
      }
    } catch (error) {
      console.error('Failed to load notifications:', error);
      showToast('Failed to load notifications', 'error');
    }
  }, [currentPage, filter, fetchNotifications, showToast]);

  // ============================================
  // FETCH ON MOUNT AND FILTER CHANGE
  // ============================================
  useEffect(() => {
    loadNotifications();
  }, [loadNotifications]);

  // ============================================
  // REFRESH HANDLER
  // ============================================
  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    await loadNotifications();
    showToast('Notifications refreshed', 'success');
    setTimeout(() => setIsRefreshing(false), 500);
  }, [loadNotifications, showToast]);

  // ============================================
  // FILTER CHANGE HANDLER
  // ============================================
  const handleFilterChange = useCallback((newFilter) => {
    setFilter(newFilter);
    setCurrentPage(1);
    setSelectedNotifications([]);
    showToast(`Showing ${newFilter} notifications`, 'info');
  }, [showToast]);

  // ============================================
  // FILTERED NOTIFICATIONS (Memoized)
  // ============================================
  const filteredNotifications = useMemo(() => {
    return notifications.filter((notif) => {
      // Search filter
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const matchesTitle = notif.title?.toLowerCase().includes(query);
        const matchesMessage = notif.message?.toLowerCase().includes(query);
        const matchesTicket = notif.ticket_number?.toLowerCase().includes(query);
        
        if (!matchesTitle && !matchesMessage && !matchesTicket) {
          return false;
        }
      }

      // Read/Unread filter
      if (filter === 'read' && !notif.is_read) return false;

      return true;
    });
  }, [notifications, searchQuery, filter]);

  // ============================================
  // NOTIFICATION CLICK HANDLER
  // ============================================
  const handleNotificationClick = useCallback(async (notification) => {
    // Mark as read if unread
    if (!notification.is_read) {
      await markAsRead(notification.notification_id);
    }

    // Navigate to related ticket if exists
    if (notification.related_ticket_id) {
      showToast('Opening ticket...', 'info');
      navigate(`/tickets/${notification.related_ticket_id}`);
    }
  }, [markAsRead, navigate, showToast]);

  // ============================================
  // MARK AS READ HANDLER
  // ============================================
  const handleMarkAsRead = useCallback(async (notificationId) => {
    try {
      await markAsRead(notificationId);
      showToast('Marked as read', 'success');
    } catch (error) {
      showToast('Failed to mark as read', 'error');
    }
  }, [markAsRead, showToast]);

  // ============================================
  // DELETE HANDLER
  // ============================================
  const handleDelete = useCallback(async (notificationId) => {
    try {
      await deleteNotification(notificationId);
      showToast('Notification deleted', 'success');
      
      // Reload if no notifications left on current page
      if (filteredNotifications.length === 1 && currentPage > 1) {
        setCurrentPage(currentPage - 1);
      } else {
        await loadNotifications();
      }
    } catch (error) {
      showToast('Failed to delete notification', 'error');
    }
  }, [deleteNotification, filteredNotifications.length, currentPage, loadNotifications, showToast]);

  // ============================================
  // MARK ALL AS READ HANDLER
  // ============================================
  const handleMarkAllAsRead = useCallback(async () => {
    try {
      await markAllAsRead();
      showToast(`${unreadCount} notifications marked as read`, 'success');
      await loadNotifications();
    } catch (error) {
      showToast('Failed to mark all as read', 'error');
    }
  }, [markAllAsRead, unreadCount, loadNotifications, showToast]);

  // ============================================
  // CLEAR READ HANDLER
  // ============================================
  const handleClearRead = useCallback(async () => {
    try {
      await clearReadNotifications();
      showToast('Read notifications cleared', 'success');
      setCurrentPage(1);
      await loadNotifications();
    } catch (error) {
      showToast('Failed to clear notifications', 'error');
    }
  }, [clearReadNotifications, loadNotifications, showToast]);

  // ============================================
  // SELECTION HANDLERS
  // ============================================
  const handleSelectNotification = useCallback((notificationId) => {
    setSelectedNotifications((prev) => {
      if (prev.includes(notificationId)) {
        return prev.filter((id) => id !== notificationId);
      }
      return [...prev, notificationId];
    });
  }, []);

  const handleSelectAll = useCallback(() => {
    if (selectedNotifications.length === filteredNotifications.length) {
      setSelectedNotifications([]);
    } else {
      setSelectedNotifications(filteredNotifications.map((n) => n.notification_id));
    }
  }, [selectedNotifications.length, filteredNotifications]);

  // ============================================
  // BULK DELETE HANDLER
  // ============================================
  const handleBulkDelete = useCallback(async () => {
    if (selectedNotifications.length === 0) return;
    
    try {
      for (const id of selectedNotifications) {
        await deleteNotification(id);
      }
      showToast(`${selectedNotifications.length} notifications deleted`, 'success');
      setSelectedNotifications([]);
      await loadNotifications();
    } catch (error) {
      showToast('Failed to delete notifications', 'error');
    }
  }, [selectedNotifications, deleteNotification, loadNotifications, showToast]);

  // ============================================
  // BULK MARK READ HANDLER
  // ============================================
  const handleBulkMarkRead = useCallback(async () => {
    if (selectedNotifications.length === 0) return;
    
    try {
      for (const id of selectedNotifications) {
        await markAsRead(id);
      }
      showToast(`${selectedNotifications.length} notifications marked as read`, 'success');
      setSelectedNotifications([]);
    } catch (error) {
      showToast('Failed to mark notifications as read', 'error');
    }
  }, [selectedNotifications, markAsRead, showToast]);

  // ============================================
  // FORMAT TIME AGO
  // ============================================
  const formatTimeAgo = useCallback((dateString) => {
    const date = new Date(dateString);
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);

    if (seconds < 60) return 'Just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
    });
  }, []);

  // ============================================
  // PAGINATION HANDLERS
  // ============================================
  const handlePrevPage = useCallback(() => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1);
      setSelectedNotifications([]);
    }
  }, [currentPage]);

  const handleNextPage = useCallback(() => {
    if (currentPage < totalPages) {
      setCurrentPage(currentPage + 1);
      setSelectedNotifications([]);
    }
  }, [currentPage, totalPages]);

  // ============================================
  // RENDER
  // ============================================
  return (
    <div className="notif-page">
      {/* Page Header */}
      <header className="notif-header">
        <div className="notif-header-content">
          <div className="notif-header-icon">
            <Bell size={28} />
            {unreadCount > 0 && (
              <span className="notif-header-badge">{unreadCount > 99 ? '99+' : unreadCount}</span>
            )}
          </div>
          <div className="notif-header-text">
            <h1 className="notif-title">Notifications</h1>
            <p className="notif-subtitle">
              {unreadCount > 0 
                ? `You have ${unreadCount} unread notification${unreadCount !== 1 ? 's' : ''}`
                : 'All notifications are read'
              }
            </p>
          </div>
        </div>

        <div className="notif-header-actions">
          <button
            type="button"
            className="notif-btn secondary"
            onClick={handleRefresh}
            disabled={isRefreshing}
            aria-label="Refresh notifications"
          >
            <RefreshCw size={18} className={isRefreshing ? 'spinning' : ''} />
            <span>Refresh</span>
          </button>
          
          {unreadCount > 0 && (
            <button
              type="button"
              className="notif-btn primary"
              onClick={handleMarkAllAsRead}
              aria-label="Mark all as read"
            >
              <CheckCheck size={18} />
              <span>Mark All Read</span>
            </button>
          )}
        </div>
      </header>

      {/* Stats Cards */}
      <div className="notif-stats-grid">
        <StatsCard
          icon={Inbox}
          label="All"
          value={totalRecords}
          color="#6366f1"
          bgColor="rgba(99, 102, 241, 0.1)"
          onClick={() => handleFilterChange('all')}
          isActive={filter === 'all'}
        />
        <StatsCard
          icon={Mail}
          label="Unread"
          value={unreadCount}
          color="#3b82f6"
          bgColor="rgba(59, 130, 246, 0.1)"
          onClick={() => handleFilterChange('unread')}
          isActive={filter === 'unread'}
        />
        <StatsCard
          icon={MailOpen}
          label="Read"
          value={totalRecords - unreadCount}
          color="#22c55e"
          bgColor="rgba(34, 197, 94, 0.1)"
          onClick={() => handleFilterChange('read')}
          isActive={filter === 'read'}
        />
      </div>

      {/* Toolbar */}
      <div className="notif-toolbar">
        <div className="notif-toolbar-left">
          {/* Search */}
          <div className="notif-search">
            <Search size={18} className="notif-search-icon" />
            <input
              type="text"
              placeholder="Search notifications..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="notif-search-input"
              aria-label="Search notifications"
            />
            {searchQuery && (
              <button
                type="button"
                className="notif-search-clear"
                onClick={() => setSearchQuery('')}
                aria-label="Clear search"
              >
                <XCircle size={16} />
              </button>
            )}
          </div>

          {/* Bulk Actions */}
          {selectedNotifications.length > 0 && (
            <div className="notif-bulk-actions">
              <span className="notif-bulk-count">
                {selectedNotifications.length} selected
              </span>
              <button
                type="button"
                className="notif-bulk-btn read"
                onClick={handleBulkMarkRead}
                title="Mark selected as read"
              >
                <Eye size={16} />
              </button>
              {canDelete && (
                <button
                  type="button"
                  className="notif-bulk-btn delete"
                  onClick={handleBulkDelete}
                  title="Delete selected"
                >
                  <Trash2 size={16} />
                </button>
              )}
            </div>
          )}
        </div>

        <div className="notif-toolbar-right">
          {canDelete && (
            <button
              type="button"
              className="notif-btn danger-outline"
              onClick={handleClearRead}
              disabled={totalRecords - unreadCount === 0}
            >
              <BellOff size={16} />
              <span>Clear Read</span>
            </button>
          )}
        </div>
      </div>

      {/* Select All */}
      {filteredNotifications.length > 0 && (
        <div className="notif-select-all">
          <label className="notif-checkbox-label">
            <input
              type="checkbox"
              checked={selectedNotifications.length === filteredNotifications.length && filteredNotifications.length > 0}
              onChange={handleSelectAll}
            />
            <span>
              Select all {filteredNotifications.length} notification{filteredNotifications.length !== 1 ? 's' : ''}
            </span>
          </label>
        </div>
      )}

      {/* Notifications List */}
      <div className="notif-container">
        {loading && filteredNotifications.length === 0 ? (
          <LoadingState />
        ) : filteredNotifications.length === 0 ? (
          <EmptyState filter={filter} searchQuery={searchQuery} />
        ) : (
          <div className="notif-list">
            {filteredNotifications.map((notification) => (
              <NotificationItem
                key={notification.notification_id}
                notification={notification}
                isSelected={selectedNotifications.includes(notification.notification_id)}
                onSelect={handleSelectNotification}
                onClick={handleNotificationClick}
                onMarkRead={handleMarkAsRead}
                onDelete={handleDelete}
                canDelete={canDelete}
                formatTime={formatTimeAgo}
              />
            ))}
          </div>
        )}
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="notif-pagination">
          <button
            type="button"
            className="notif-page-btn"
            disabled={currentPage === 1}
            onClick={handlePrevPage}
            aria-label="Previous page"
          >
            <ChevronLeft size={18} />
            <span>Previous</span>
          </button>

          <div className="notif-page-info">
            <span className="notif-page-current">{currentPage}</span>
            <span className="notif-page-separator">of</span>
            <span className="notif-page-total">{totalPages}</span>
          </div>

          <button
            type="button"
            className="notif-page-btn"
            disabled={currentPage === totalPages}
            onClick={handleNextPage}
            aria-label="Next page"
          >
            <span>Next</span>
            <ChevronRight size={18} />
          </button>
        </div>
      )}
    </div>
  );
};

// ============================================
// EXPORT
// ============================================
export default AllNotifications;