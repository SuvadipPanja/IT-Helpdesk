// ============================================
// BACKUP SERVICE - FIXED VERSION
// Core backup logic for database and file backups
// Developer: Suvadip Panja
// Date: January 30, 2026
// FIXED: Database backup path simplified for SQL Server permissions
// FILE: backend/services/backup.service.js
// ============================================

const path = require('path');
const fs = require('fs');
const fsPromises = require('fs').promises;
const { executeQuery } = require('../config/database');
const logger = require('../utils/logger');
const settingsService = require('./settings.service');

// ============================================
// BACKUP CONFIGURATION
// ============================================
const BACKUP_ROOT = path.join(__dirname, '../../Data_Backup');

// Ensure backup directory exists
if (!fs.existsSync(BACKUP_ROOT)) {
  fs.mkdirSync(BACKUP_ROOT, { recursive: true });
  logger.info('Created backup root directory', { path: BACKUP_ROOT });
}

// ============================================
// CREATE BACKUP (MAIN FUNCTION)
// ============================================
const createBackup = async (trigger = 'AUTOMATIC', userId = null) => {
  const startTime = Date.now();
  let backupId = null;

  try {
    logger.separator('BACKUP CREATION');
    logger.try('Starting backup process', { trigger, userId });

    // ============================================
    // STEP 1: LOAD SETTINGS
    // ============================================
    logger.try('Loading backup settings from database');
    const settings = await settingsService.getByCategory('backup');

    const backupEnabled = settings.backup_enabled === 'true' || settings.backup_enabled === true;

    if (!backupEnabled) {
      logger.warn('Backup is disabled in settings');
      return {
        success: false,
        message: 'Backup is disabled in system settings'
      };
    }

    logger.success('Backup settings loaded', {
      enabled: backupEnabled,
      frequency: settings.backup_frequency,
      retentionDays: settings.backup_retention_days
    });

    // ============================================
    // STEP 2: CREATE BACKUP DIRECTORY
    // ============================================
    const timestamp = new Date().toISOString()
      .replace(/T/, '_')
      .replace(/:/g, '-')
      .replace(/\..+/, '')
      .substring(0, 19);

    const backupName = `BACKUP_${timestamp.replace(/[-_]/g, '').replace(/T/, '_')}`;
    const backupDir = path.join(BACKUP_ROOT, timestamp);
    const filesDir = path.join(backupDir, 'files');

    logger.try('Creating backup directories', { backupDir });

    // Create directories
    await fsPromises.mkdir(backupDir, { recursive: true });
    await fsPromises.mkdir(filesDir, { recursive: true });

    logger.success('Backup directories created');

    // ============================================
    // STEP 3: INSERT BACKUP RECORD (IN_PROGRESS)
    // ============================================
    logger.try('Creating backup record in database');

    const insertQuery = `
      INSERT INTO backup_history (
        backup_name,
        backup_type,
        backup_trigger,
        backup_path,
        status,
        started_at,
        database_included,
        files_included,
        created_by
      )
      OUTPUT INSERTED.backup_id
      VALUES (
        @backupName,
        'FULL',
        @trigger,
        @backupPath,
        'IN_PROGRESS',
        GETDATE(),
        1,
        1,
        @userId
      )
    `;

    const result = await executeQuery(insertQuery, {
      backupName,
      trigger,
      backupPath: backupDir,
      userId: userId || null
    });

    backupId = result.recordset[0].backup_id;
    logger.success('Backup record created', { backupId });

    // ============================================
    // STEP 4: BACKUP DATABASE
    // ============================================
    logger.try('Starting database backup');

    // ðŸ”§ FIX: Put database backup directly in Data_Backup folder
    // This avoids SQL Server permission issues with nested folders
    const databaseBackupPath = path.join(BACKUP_ROOT, `${backupName}.bak`);
    const databaseSizeMB = await backupDatabase(databaseBackupPath);

    logger.success('Database backup completed', {
      path: databaseBackupPath,
      sizeMB: databaseSizeMB
    });

    // ============================================
    // STEP 5: BACKUP FILES
    // ============================================
    logger.try('Starting file backup');

    const uploadsDir = path.join(__dirname, '../uploads');
    const fileBackupResult = await backupFiles(uploadsDir, filesDir);

    logger.success('File backup completed', {
      filesCount: fileBackupResult.filesCount,
      sizeMB: fileBackupResult.sizeMB
    });

    // ============================================
    // STEP 6: CREATE METADATA FILE
    // ============================================
    const metadata = {
      backupName,
      backupId,
      trigger,
      timestamp,
      database: {
        included: true,
        path: databaseBackupPath,
        sizeMB: databaseSizeMB
      },
      files: {
        included: true,
        path: filesDir,
        count: fileBackupResult.filesCount,
        sizeMB: fileBackupResult.sizeMB
      },
      total: {
        sizeMB: databaseSizeMB + fileBackupResult.sizeMB
      },
      createdBy: userId,
      createdAt: new Date().toISOString()
    };

    const metadataPath = path.join(backupDir, 'metadata.json');
    await fsPromises.writeFile(metadataPath, JSON.stringify(metadata, null, 2));

    logger.success('Metadata file created', { path: metadataPath });

    // ============================================
    // STEP 7: UPDATE BACKUP RECORD (COMPLETED)
    // ============================================
    const durationSeconds = Math.floor((Date.now() - startTime) / 1000);
    const totalSizeMB = databaseSizeMB + fileBackupResult.sizeMB;

    const updateQuery = `
      UPDATE backup_history
      SET 
        database_backup_path = @databasePath,
        files_backup_path = @filesPath,
        database_size_mb = @databaseSizeMB,
        files_size_mb = @filesSizeMB,
        total_size_mb = @totalSizeMB,
        files_count = @filesCount,
        status = 'COMPLETED',
        completed_at = GETDATE(),
        duration_seconds = @durationSeconds
      WHERE backup_id = @backupId
    `;

    await executeQuery(updateQuery, {
      backupId,
      databasePath: databaseBackupPath,
      filesPath: filesDir,
      databaseSizeMB,
      filesSizeMB: fileBackupResult.sizeMB,
      totalSizeMB,
      filesCount: fileBackupResult.filesCount,
      durationSeconds
    });

    logger.success('Backup record updated to COMPLETED');

    // ============================================
    // STEP 8: CLEANUP OLD BACKUPS
    // ============================================
    logger.try('Cleaning up old backups');
    const retentionDays = parseInt(settings.backup_retention_days) || 30;
    await cleanupOldBackups(retentionDays);

    logger.separator();
    logger.success('âœ… BACKUP COMPLETED SUCCESSFULLY', {
      backupId,
      backupName,
      durationSeconds,
      totalSizeMB: totalSizeMB.toFixed(2),
      filesCount: fileBackupResult.filesCount
    });
    logger.separator();

    return {
      success: true,
      message: 'Backup created successfully',
      data: {
        backupId,
        backupName,
        backupPath: backupDir,
        databaseSizeMB,
        filesSizeMB: fileBackupResult.sizeMB,
        totalSizeMB,
        filesCount: fileBackupResult.filesCount,
        durationSeconds
      }
    };

  } catch (error) {
    logger.error('Backup creation failed', error);

    // Update backup record to FAILED if backupId exists
    if (backupId) {
      try {
        const durationSeconds = Math.floor((Date.now() - startTime) / 1000);
        const updateQuery = `
          UPDATE backup_history
          SET 
            status = 'FAILED',
            completed_at = GETDATE(),
            duration_seconds = @durationSeconds,
            error_message = @errorMessage
          WHERE backup_id = @backupId
        `;

        await executeQuery(updateQuery, {
          backupId,
          durationSeconds,
          errorMessage: error.message.substring(0, 500)
        });

        logger.info('[SYSTEM] Backup record updated to FAILED');
      } catch (updateError) {
        logger.error('Failed to update backup record to FAILED', updateError);
      }
    }

    throw error;
  }
};

// ============================================
// BACKUP DATABASE (SQL SERVER)
// ============================================
const backupDatabase = async (backupPath) => {
  try {
    logger.try('Executing SQL Server BACKUP command');

    // ðŸ”§ FIX: Ensure path uses forward slashes for SQL Server
    // SQL Server accepts forward slashes and they work better than backslashes
    const sqlPath = backupPath.replace(/\\/g, '/');

    const backupQuery = `
      BACKUP DATABASE [ITHelpdesk]
      TO DISK = N'${sqlPath}'
      WITH FORMAT,
           INIT,
           COMPRESSION,
           STATS = 10,
           NAME = N'Full Backup of ITHelpdesk'
    `;

    logger.info('SQL Backup command', { path: sqlPath });

    await executeQuery(backupQuery);

    // Wait a moment for file to be fully written
    await new Promise(resolve => setTimeout(resolve, 500));

    // Get backup file size
    const stats = await fsPromises.stat(backupPath);
    const sizeMB = parseFloat((stats.size / (1024 * 1024)).toFixed(2));

    logger.success('Database backup completed', {
      path: backupPath,
      sizeMB
    });

    return sizeMB;

  } catch (error) {
    logger.error('Database backup failed', error);
    throw new Error(`Database backup failed: ${error.message}`);
  }
};

// ============================================
// BACKUP FILES (COPY UPLOADS DIRECTORY)
// ============================================
const backupFiles = async (sourceDir, targetDir) => {
  try {
    logger.try('Copying files from uploads directory', { sourceDir, targetDir });

    let filesCount = 0;
    let totalSize = 0;

    // Check if source directory exists
    if (!fs.existsSync(sourceDir)) {
      logger.warn('Source directory does not exist', { sourceDir });
      return { filesCount: 0, sizeMB: 0 };
    }

    // Recursive copy function
    const copyRecursive = async (src, dest) => {
      const entries = await fsPromises.readdir(src, { withFileTypes: true });

      for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        if (entry.isDirectory()) {
          await fsPromises.mkdir(destPath, { recursive: true });
          await copyRecursive(srcPath, destPath);
        } else {
          await fsPromises.copyFile(srcPath, destPath);
          const stats = await fsPromises.stat(srcPath);
          totalSize += stats.size;
          filesCount++;
        }
      }
    };

    await copyRecursive(sourceDir, targetDir);

    const sizeMB = parseFloat((totalSize / (1024 * 1024)).toFixed(2));

    logger.success('Files copied successfully', { filesCount, sizeMB });

    return {
      filesCount,
      sizeMB
    };

  } catch (error) {
    logger.error('File backup failed', error);
    throw new Error(`File backup failed: ${error.message}`);
  }
};

// ============================================
// CLEANUP OLD BACKUPS
// ============================================
const cleanupOldBackups = async (retentionDays = 30) => {
  try {
    logger.try('Cleaning up backups older than retention period', { retentionDays });

    // Calculate cutoff date
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

    // Get old backups from database
    const query = `
      SELECT backup_id, backup_name, backup_path, database_backup_path
      FROM backup_history
      WHERE created_at < @cutoffDate
        AND status IN ('COMPLETED', 'FAILED')
    `;

    const result = await executeQuery(query, {
      cutoffDate: cutoffDate.toISOString()
    });

    const oldBackups = result.recordset;

    if (oldBackups.length === 0) {
      logger.info('No old backups to clean up');
      return { deletedCount: 0 };
    }

    logger.info(`Found ${oldBackups.length} old backups to delete`);

    let deletedCount = 0;

    for (const backup of oldBackups) {
      try {
        // Delete backup folder if exists
        if (backup.backup_path && fs.existsSync(backup.backup_path)) {
          await fsPromises.rm(backup.backup_path, { recursive: true, force: true });
          logger.info('Deleted backup folder', { path: backup.backup_path });
        }

        // Delete database backup file if exists (and is separate)
        if (backup.database_backup_path && 
            fs.existsSync(backup.database_backup_path) &&
            backup.database_backup_path !== backup.backup_path) {
          await fsPromises.unlink(backup.database_backup_path);
          logger.info('Deleted database backup file', { path: backup.database_backup_path });
        }

        // Delete record from database
        const deleteQuery = `
          DELETE FROM backup_history
          WHERE backup_id = @backupId
        `;

        await executeQuery(deleteQuery, { backupId: backup.backup_id });

        deletedCount++;
        logger.info('Deleted backup record', { 
          backupId: backup.backup_id, 
          backupName: backup.backup_name 
        });

      } catch (error) {
        logger.error(`Failed to delete backup ${backup.backup_name}`, error);
      }
    }

    logger.success('Cleanup completed', { deletedCount });

    return { deletedCount };

  } catch (error) {
    logger.error('Cleanup failed', error);
    throw new Error(`Cleanup failed: ${error.message}`);
  }
};

// ============================================
// GET BACKUP HISTORY (WITH PAGINATION)
// ============================================
const getBackupHistory = async (page = 1, limit = 10) => {
  try {
    // ðŸ”§ FIX: Ensure page and limit are valid integers to prevent NaN in SQL
    const validPage = Math.max(1, parseInt(page) || 1);
    const validLimit = Math.max(1, Math.min(100, parseInt(limit) || 10));
    const offset = (validPage - 1) * validLimit;

    // Get total count
    const countQuery = `
      SELECT COUNT(*) as total
      FROM backup_history
    `;

    const countResult = await executeQuery(countQuery);
    const totalCount = countResult.recordset[0].total;

    // Get paginated backups
    const query = `
      SELECT 
        bh.backup_id,
        bh.backup_name,
        bh.backup_type,
        bh.backup_trigger,
        bh.backup_path,
        bh.database_backup_path,
        bh.files_backup_path,
        bh.status,
        bh.started_at,
        bh.completed_at,
        bh.duration_seconds,
        bh.database_size_mb,
        bh.files_size_mb,
        bh.total_size_mb,
        bh.files_count,
        bh.error_message,
        bh.created_at,
        bh.created_by,
        u.username as created_by_name,
        u.email as created_by_email
      FROM backup_history bh
      LEFT JOIN users u ON bh.created_by = u.user_id
      ORDER BY bh.created_at DESC
      OFFSET ${offset} ROWS
      FETCH NEXT ${validLimit} ROWS ONLY
    `;

    const result = await executeQuery(query);

    const totalPages = Math.ceil(totalCount / validLimit);

    return {
      backups: result.recordset,
      pagination: {
        currentPage: validPage,
        totalPages,
        totalCount,
        limit: validLimit,
        hasNext: validPage < totalPages,
        hasPrev: validPage > 1
      }
    };

  } catch (error) {
    logger.error('Failed to get backup history', error);
    throw new Error(`Failed to get backup history: ${error.message}`);
  }
};

// ============================================
// GET BACKUP BY ID
// ============================================
const getBackupById = async (backupId) => {
  try {
    const query = `
      SELECT 
        bh.backup_id,
        bh.backup_name,
        bh.backup_type,
        bh.backup_trigger,
        bh.backup_path,
        bh.database_backup_path,
        bh.files_backup_path,
        bh.status,
        bh.started_at,
        bh.completed_at,
        bh.duration_seconds,
        bh.database_size_mb,
        bh.files_size_mb,
        bh.total_size_mb,
        bh.files_count,
        bh.error_message,
        bh.created_at,
        bh.created_by,
        u.username as created_by_name,
        u.email as created_by_email
      FROM backup_history bh
      LEFT JOIN users u ON bh.created_by = u.user_id
      WHERE bh.backup_id = @backupId
    `;

    const result = await executeQuery(query, { backupId });

    if (result.recordset.length === 0) {
      return null;
    }

    return result.recordset[0];

  } catch (error) {
    logger.error('Failed to get backup by ID', error);
    throw new Error(`Failed to get backup by ID: ${error.message}`);
  }
};

// ============================================
// DELETE BACKUP
// ============================================
const deleteBackup = async (backupId) => {
  try {
    logger.try('Deleting backup', { backupId });

    // Get backup details
    const backup = await getBackupById(backupId);

    if (!backup) {
      throw new Error('Backup not found');
    }

    // Delete backup folder if exists
    if (backup.backup_path && fs.existsSync(backup.backup_path)) {
      await fsPromises.rm(backup.backup_path, { recursive: true, force: true });
      logger.info('Deleted backup folder', { path: backup.backup_path });
    }

    // Delete database backup file if exists (and is separate)
    if (backup.database_backup_path && 
        fs.existsSync(backup.database_backup_path) &&
        backup.database_backup_path !== backup.backup_path) {
      await fsPromises.unlink(backup.database_backup_path);
      logger.info('Deleted database backup file', { path: backup.database_backup_path });
    }

    // Delete record from database
    const deleteQuery = `
      DELETE FROM backup_history
      WHERE backup_id = @backupId
    `;

    await executeQuery(deleteQuery, { backupId });

    logger.success('Backup deleted successfully', { backupId });

    return {
      success: true,
      message: 'Backup deleted successfully'
    };

  } catch (error) {
    logger.error('Failed to delete backup', error);
    throw new Error(`Failed to delete backup: ${error.message}`);
  }
};

// ============================================
// GET BACKUP STATISTICS
// ============================================
const getBackupStats = async () => {
  try {
    const query = `
      SELECT 
        COUNT(*) as total_backups,
        SUM(CASE WHEN status = 'COMPLETED' THEN 1 ELSE 0 END) as completed_backups,
        SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed_backups,
        SUM(CASE WHEN status = 'IN_PROGRESS' THEN 1 ELSE 0 END) as in_progress_backups,
        COALESCE(SUM(total_size_mb), 0) as total_size_mb,
        COALESCE(AVG(CASE WHEN status = 'COMPLETED' THEN duration_seconds END), 0) as avg_duration_seconds
      FROM backup_history
    `;

    const result = await executeQuery(query);

    return result.recordset[0];

  } catch (error) {
    logger.error('Failed to get backup statistics', error);
    throw new Error(`Failed to get backup statistics: ${error.message}`);
  }
};

// ============================================
// EXPORTS
// ============================================
module.exports = {
  createBackup,
  getBackupHistory,
  getBackupById,
  deleteBackup,
  getBackupStats,
  cleanupOldBackups
};