// ============================================
// Ultimate Logger Utility
// Production-grade logging: Async, rotatable, traceable, with AI-inspired human-centric formatting
// Features: Correlation IDs, categorized actions, concise messages, emoji-rich visuals, error boxing, and metrics
// ============================================

const fs = require('fs').promises;
const path = require('path');
const util = require('util');
const { performance } = require('perf_hooks'); // For timing
const os = require('os'); // For system details

// Extended ANSI colors for immersive console experience
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  underline: '\x1b[4m',
  inverse: '\x1b[7m',
  
  // Foreground
  black: '\x1b[30m', red: '\x1b[31m', green: '\x1b[32m', yellow: '\x1b[33m',
  blue: '\x1b[34m', magenta: '\x1b[35m', cyan: '\x1b[36m', white: '\x1b[37m',
  gray: '\x1b[90m',
  
  // Background
  bgBlack: '\x1b[40m', bgRed: '\x1b[41m', bgGreen: '\x1b[42m', bgYellow: '\x1b[43m',
  bgBlue: '\x1b[44m', bgMagenta: '\x1b[45m', bgCyan: '\x1b[46m', bgWhite: '\x1b[47m',
};

// Category-specific colors for actions (extendable)
const CATEGORY_COLORS = {
  auth: colors.green,
  query: colors.blue,
  request: colors.cyan,
  response: colors.magenta,
  upload: colors.yellow,
  escalation: colors.bright + colors.red,  // e.g., for auto-escalation
  startup: colors.green,
  shutdown: colors.red,
  system: colors.cyan,
  default: colors.white,
};

// Rich log levels: Icons, colors, priorities, and visual styles
const LOG_LEVELS = {
  ERROR: { name: 'ERROR', fg: colors.red, bg: colors.bgRed, icon: '🚨', priority: 0, style: 'boxed' },
  WARN: { name: 'WARN', fg: colors.yellow, bg: colors.bgYellow, icon: '⚠️', priority: 1, style: 'bold' },
  INFO: { name: 'INFO', fg: colors.cyan, icon: 'ℹ️', priority: 2, style: 'normal' },
  SUCCESS: { name: 'SUCCESS', fg: colors.green, bg: colors.bgGreen, icon: '✅', priority: 3, style: 'bold' },
  DEBUG: { name: 'DEBUG', fg: colors.magenta, icon: '🐛', priority: 4, style: 'dim' },
  TRY: { name: 'TRY', fg: colors.blue, icon: '🔄', priority: 5, style: 'italic' },
  FAIL: { name: 'FAIL', fg: colors.red, bg: colors.bgRed, icon: '❌', priority: 0, style: 'boxed' },
};

class UltimateLogger {
  constructor() {
    this.logsDir = path.join(__dirname, '../logs');
    this.currentLogLevel = process.env.LOG_LEVEL || 'INFO';
    this.enableFileLogging = process.env.ENABLE_FILE_LOGGING !== 'false';
    this.enableConsoleLogging = process.env.ENABLE_CONSOLE_LOGGING !== 'false';
    this.maxFileSize = parseInt(process.env.MAX_LOG_FILE_SIZE) || 5 * 1024 * 1024; // 5MB for faster rotation
    this.correlationId = null;
    this.requestStartTimes = new Map(); // For per-request timing
    
    // Async init
    this.init().catch(() => {});
  }

  async init() {
    await fs.mkdir(this.logsDir, { recursive: true });
    // Avoid early logging during init to prevent potential issues
  }

  /**
   * Get local IPv4 address
   * @returns {string}
   */
  getLocalIP() {
    const interfaces = os.networkInterfaces();
    for (const name of Object.keys(interfaces)) {
      for (const iface of interfaces[name]) {
        if (iface.family === 'IPv4' && !iface.internal) {
          return iface.address;
        }
      }
    }
    return 'unknown';
  }

  /**
   * Get MAC address from primary interface
   * @returns {string}
   */
  getMAC() {
    const interfaces = os.networkInterfaces();
    for (const name of Object.keys(interfaces)) {
      for (const iface of interfaces[name]) {
        if (iface.family === 'IPv4' && !iface.internal && iface.mac) {
          return iface.mac;
        }
      }
    }
    return 'unknown';
  }

  /**
   * Get inferred location from timezone
   * @returns {string}
   */
  getLocationFromTimezone() {
    const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    // Simple mapping for common timezones; extend as needed
    const tzMap = {
      'Asia/Kolkata': 'Kolkata, India',
      'America/New_York': 'New York, USA',
      'Europe/London': 'London, UK',
      // Add more if needed
    };
    return tzMap[timeZone] || timeZone;
  }

  /**
   * Set request correlation and start timer
   * @param {string} id
   * @param {Object} req - Optional for timing
   */
  startRequest(id, req) {
    this.correlationId = id || `req-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    if (req) this.requestStartTimes.set(this.correlationId, performance.now());
    return this.correlationId;
  }

  /**
   * End request timing and clear
   * @param {string} id
   * @returns {number} Duration ms
   */
  endRequest(id) {
    const start = this.requestStartTimes.get(id);
    this.requestStartTimes.delete(id);
    this.correlationId = null;
    return start ? performance.now() - start : 0;
  }

  /**
   * Clean IST timestamp (fixed with UTC methods for accurate components)
   * @returns {string}
   */
  getTimestamp() {
    const now = new Date();
    const istOffset = 5.5 * 60 * 60 * 1000;
    const istTime = new Date(now.getTime() + istOffset);
    
    const year = istTime.getUTCFullYear();
    const month = String(istTime.getUTCMonth() + 1).padStart(2, '0');
    const day = String(istTime.getUTCDate()).padStart(2, '0');
    const hours = String(istTime.getUTCHours()).padStart(2, '0');
    const minutes = String(istTime.getUTCMinutes()).padStart(2, '0');
    const seconds = String(istTime.getUTCSeconds()).padStart(2, '0');
    const milliseconds = String(istTime.getUTCMilliseconds()).padStart(3, '0');
    
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;
  }

  getLogFilename() {
    const now = new Date();
    const istOffset = 5.5 * 60 * 60 * 1000;
    const istTime = new Date(now.getTime() + istOffset);
    
    const year = istTime.getUTCFullYear();
    const month = String(istTime.getUTCMonth() + 1).padStart(2, '0');
    const day = String(istTime.getUTCDate()).padStart(2, '0');
    
    return `app-${year}-${month}-${day}.log`;
  }

  async rotateIfNeeded(filePath) {
    try {
      const stats = await fs.stat(filePath).catch(() => ({ size: 0 }));
      if (stats.size > this.maxFileSize) {
        const timestamp = Date.now();
        const ext = path.extname(filePath);
        const name = path.basename(filePath, ext);
        const dir = path.dirname(filePath);
        const rotated = path.join(dir, `${name}.rotated-${timestamp}${ext}`);
        await fs.rename(filePath, rotated);
        console.log(`${colors.yellow}Log file rotated: ${rotated}${colors.reset}`); // Direct console for rotation
      }
    } catch {}
  }

  createLogObject(level, message, data = {}) {
    // Clean, concise log: Remove unnecessary fields, trim message
    const cleanMessage = message.trim().replace(/\s+/g, ' ').replace(/\(Execution ID: (\d+)\)/, '[$1]'); // e.g., simplify "Processing auto-escalation (Execution ID: 27)" to "Processing auto-escalation [27]"
    const log = {
      timestamp: this.getTimestamp(),
      level: LOG_LEVELS[level]?.name || level,
      category: data.category || 'general',  // Categorize actions
      message: cleanMessage,
      data: this._sanitizeData(data),
    };
    if (this.correlationId) log.correlationId = this.correlationId;
    // Removed relativeTime for cleanliness
    return log;
  }

  _sanitizeData(data) {
    if (!data || typeof data !== 'object') return data;
    const clean = { ...data };
    // Remove unnecessary/sensitive keys
    ['password', 'token', 'secret', 'relativeTime'].forEach(key => delete clean[key]);
    // Truncate long strings
    Object.keys(clean).forEach(key => {
      if (typeof clean[key] === 'string' && clean[key].length > 100) {  // Shorter truncate for handiness
        clean[key] = clean[key].substring(0, 100) + '...';
      }
    });
    // Remove category from data if present (moved to top-level)
    delete clean.category;
    return clean;
  }

  async writeToFile(logObject) {
    if (!this.enableFileLogging) return;
    try {
      const filePath = path.join(this.logsDir, this.getLogFilename());
      await this.rotateIfNeeded(filePath);
      // Human-readable line: timestamp [LEVEL] [CATEGORY if different] icon message [data if any]
      const levelConfig = LOG_LEVELS[logObject.level] || LOG_LEVELS.INFO;
      const icon = levelConfig.icon;
      let catStr = '';
      const levelLower = logObject.level.toLowerCase();
      const catLower = logObject.category.toLowerCase();
      if (catLower !== levelLower && catLower !== 'general') {
        catStr = `[${logObject.category.toUpperCase()}] `;
      }
      let dataStr = '';
      if (Object.keys(logObject.data).length > 0) {
        dataStr = ` | ${JSON.stringify(logObject.data).substring(1, -1)}`;  // Inline data without {}
      }
      const logLine = `${logObject.timestamp} [${logObject.level}] ${catStr}${icon} ${logObject.message}${dataStr}`;
      await fs.appendFile(filePath, logLine + '\n', 'utf8');
    } catch (err) {
      console.error('File log failed:', err.message); // Fallback
    }
  }

  writeToConsole(logObject) {
    if (!this.enableConsoleLogging) return;
    const levelConfig = LOG_LEVELS[logObject.level] || LOG_LEVELS.INFO;
    const prio = LOG_LEVELS[this.currentLogLevel]?.priority ?? 2;
    if (prio < levelConfig.priority) return;

    const { timestamp, message, data, correlationId, category } = logObject;
    const { fg, bg, icon, style } = levelConfig;
    const catColor = CATEGORY_COLORS[category] || CATEGORY_COLORS.default;

    // Build header with category color (skip if same as level)
    let header = `${colors.bright}${timestamp}${colors.reset} ${fg}${bg ? bg : ''}${icon} ${levelConfig.name}${colors.reset}`;
    if (correlationId) header += ` ${colors.dim}[${correlationId.slice(-8)}]${colors.reset}`;
    const levelLower = logObject.level.toLowerCase();
    const catLower = category.toLowerCase();
    if (catLower !== levelLower && catLower !== 'general') {
      header += ` ${catColor}[${category.toUpperCase()}]${colors.reset}`;
    }
    header += ` ${message}`;

    // Apply style
    if (style === 'boxed' && (levelConfig.name === 'ERROR' || levelConfig.name === 'FAIL')) {
      this._boxMessage(header, fg);
    } else if (style === 'bold') {
      header = `${colors.bright}${header}${colors.reset}`;
    } else if (style === 'dim') {
      header = `${colors.dim}${header}${colors.reset}`;
    }
    console.log(header);

    // Enhanced data rendering (simplified list to avoid table padding issues)
    if (data && Object.keys(data).length > 0) {
      console.log(`${colors.blue}📊 Details:${colors.reset}`);
      const entries = Object.entries(this._sanitizeData(data)).filter(([k]) => !['stack', 'error'].includes(k) || levelConfig.name === 'ERROR');
      entries.slice(0, 5).forEach(([key, val]) => {  // Limit to 5 for handiness
        let displayVal = this._formatValue(val);
        if (String(displayVal).length > 60) displayVal = String(displayVal).substring(0, 57) + '...';
        console.log(`  ${colors.cyan}• ${colors.bright}${key}: ${colors.reset}${displayVal}`);
      });
      if (entries.length > 5) {
        console.log(`  ${colors.gray}... +${entries.length - 5} more${colors.reset}`);
      }

      // Special error stack (concise)
      if (data.stack && levelConfig.name === 'ERROR') {
        console.log(`${colors.red}💥 Stack:${colors.reset}`);
        data.stack.split('\n').slice(0, 5).forEach(line => console.log(`  ${colors.dim}${line.trim()}${colors.reset}`));  // Limit to 5
      }
    }

    // Metrics if timing present
    if (data?.durationMs) {
      const bar = this._progressBar(data.durationMs, 100);
      console.log(`${colors.gray}⏱️ ${bar} ${data.durationMs}ms${colors.reset}`);
    }

    console.log(''); // Clean separation
  }

  _boxMessage(msg, color) {
    const lines = msg.split('\n');
    const width = Math.max(...lines.map(l => l.length)) + 4;
    const top = `${color}┌${'─'.repeat(width)}┐${colors.reset}`;
    const bot = `${color}└${'─'.repeat(width)}┘${colors.reset}`;
    const mid = lines.map(line => `${color}│ ${line.padEnd(width - 2)} │${colors.reset}`).join('\n');
    console.log(top);
    console.log(mid);
    console.log(bot);
  }

  _formatValue(val) {
    if (val === null || val === undefined) return colors.gray + 'N/A' + colors.reset;
    if (typeof val === 'object') return util.inspect(val, { depth: 2, colors: true, compact: true });  // Reduced depth
    if (typeof val === 'number') {
      return val > 1000 ? `${val.toLocaleString()} (${(val / 1000).toFixed(1)}k)` : val;
    }
    return String(val);
  }

  _progressBar(duration, threshold) {
    const percent = Math.min(duration / threshold * 100, 100);
    const filled = Math.floor(percent / 5);  // Shorter bar
    const bar = '█'.repeat(filled) + '░'.repeat(20 - filled);
    const color = percent > 80 ? colors.red : percent > 50 ? colors.yellow : colors.green;
    return `${color}[${bar}]${colors.reset}`;
  }

  async log(level, message, data = {}) {
    const logObj = this.createLogObject(level, message, data);
    this.writeToConsole(logObj);
    await this.writeToFile(logObj);
  }

  // Async convenience methods (with category support, default to 'system' to avoid duplication)
  async error(msg, errOrData = {}, category = 'error') {
    const data = { ...errOrData, category };
    if (errOrData instanceof Error) {
      data.error = errOrData.message;
      data.stack = errOrData.stack;
      data.code = errOrData.code;
    }
    await this.log('ERROR', msg, data);
  }

  async warn(msg, data = {}, category = 'system') {
    data.category = category;
    await this.log('WARN', msg, data);
  }

  async info(msg, data = {}, category = 'system') {
    data.category = category;
    await this.log('INFO', msg, data);
  }

  async success(msg, data = {}, category = 'operation') {
    data.category = category;
    await this.log('SUCCESS', msg, data);
  }

  async debug(msg, data = {}, category = 'debug') {
    data.category = category;
    await this.log('DEBUG', msg, data);
  }

  async try(msg, data = {}, category = 'operation') {
    data.category = category;
    await this.log('TRY', msg, data);
  }

  async fail(msg, data = {}, category = 'operation') {
    data.category = category;
    await this.log('FAIL', msg, data);
  }

  // Supercharged specialized logs (with categories, concise messages)
  async logRequest(req, category = 'request') {
    const id = this.startRequest(req.headers['x-request-id'] || req.user?.user_id?.toString() || null, req);
    await this.info(`Incoming [${req.method}] ${req.originalUrl}`, {
      id,
      ip: req.ip || 'unknown',
      ua: (req.get('User-Agent') || 'N/A').substring(0, 50),
      userId: req.user?.user_id || 'anon',
      category,
    });
  }

  async logResponse(req, res, duration, category = 'response') {
    const id = this.correlationId;
    const status = `${res.statusCode}`;
    const level = res.statusCode >= 500 ? 'ERROR' : res.statusCode >= 400 ? 'WARN' : 'SUCCESS';
    await this.log(level, `Response [${status}] ${duration}ms`, {
      id,
      method: req.method,
      path: req.originalUrl,
      userId: req.user?.user_id || 'anon',
      size: res.get('Content-Length') || 'N/A',
      durationMs: duration,
      category,
    });
    this.endRequest(id);
  }

  async logQuery(query, params = {}, duration = 0, rows = 0, category = 'query') {
    await this.debug(`Query [${duration}ms]`, {
      sql: query.length > 100 ? query.substring(0, 100) + '...' : query,
      paramsCount: Object.keys(params).length,
      rowsAffected: rows,
      category,
    });
  }

  async logAuth(username, success, ip, method = 'session', category = 'auth') {
    const action = success ? 'Success' : 'Failure';
    const level = success ? 'SUCCESS' : 'WARN';
    await this.log(level, `Auth ${action}: ${username}`, {
      ip,
      method,
      category,
    });
  }

  async logFileUpload(filename, sizeBytes, userId, mimeType = 'unknown', category = 'upload') {
    await this.info(`Upload: ${path.basename(filename)}`, {
      size: `${(sizeBytes / 1024 / 1024).toFixed(1)}MB`,
      mimeType,
      userId,
      category,
    });
  }

  // Example for auto-escalation (concise)
  async logEscalation(executionId, category = 'escalation') {
    await this.info(`Auto-escalation [${executionId}]`, { category });
  }

  separator(title = '') {
    const line = `${colors.yellow}╭${'─'.repeat(98)}╮${colors.reset}`;
    console.log(line);
    if (title) console.log(`${colors.bright}│ ${title.padEnd(96)} │${colors.reset}`);
    console.log(`${colors.yellow}╰${'─'.repeat(98)}╯${colors.reset}`);
  }

  async logStartup(port, env) {
    this.separator('🚀 ULTIMATE LOGGER & APP STARTED');
    const developer = 'Suvadip Panja';
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const location = this.getLocationFromTimezone();
    const ip = this.getLocalIP();
    const mac = this.getMAC();
    await this.success(`Ready! Port: ${port} | Env: ${env.toUpperCase()} | Developer: ${developer}`, {
      node: process.version,
      uptime: process.uptime().toFixed(1) + 's',
      pid: process.pid,
      timezone,
      location,
      ip,
      mac,
      category: 'startup',
    });
    this.separator();
  }

  async logShutdown() {
    this.separator('🛑 SHUTDOWN INITIATED');
    await this.info('Logs flushed. Goodbye!', { category: 'shutdown' });
    this.separator();
  }
}

// Export singleton
module.exports = new UltimateLogger(); 