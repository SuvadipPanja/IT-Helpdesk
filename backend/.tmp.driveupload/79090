// ============================================
// Dashboard Controller — Enhanced v2
// Production-ready with parameterized queries,
// consolidated SQL, trend data, and activity feed
// ============================================

const { executeQuery } = require('../config/database');
const { createResponse } = require('../utils/helpers');
const logger = require('../utils/logger');

/**
 * Get Dashboard Statistics — Enhanced
 * @route GET /api/v1/dashboard/stats
 * @access Private
 */
const getDashboardStats = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const canViewAll = req.user.permissions?.can_view_all_tickets || false;

    logger.info('Fetching dashboard statistics', { userId, canViewAll });

    // ── Build safe ticket filter ──
    const ticketWhere = canViewAll
      ? '1=1'
      : '(t.requester_id = @userId OR t.assigned_to = @userId)';

    const params = { userId };

    // ── CONSOLIDATED QUERY: Summary + Status + Priority + SLA (server-side) ──
    const mainQuery = `
      -- 1) Ticket status counts
      SELECT
        ts.status_code,
        ts.status_name,
        COUNT(t.ticket_id) AS cnt
      FROM ticket_statuses ts
      LEFT JOIN tickets t ON ts.status_id = t.status_id AND ${ticketWhere}
      WHERE ts.is_active = 1
      GROUP BY ts.status_code, ts.status_name, ts.status_id
      ORDER BY ts.status_id;

      -- 2) Priority distribution
      SELECT
        tp.priority_code,
        tp.priority_name,
        COUNT(t.ticket_id) AS cnt
      FROM ticket_priorities tp
      LEFT JOIN tickets t ON tp.priority_id = t.priority_id AND ${ticketWhere}
      WHERE ISNULL(tp.is_active, 1) = 1
      GROUP BY tp.priority_code, tp.priority_name, tp.priority_level
      ORDER BY tp.priority_level DESC;

      -- 3) SLA summary (computed in SQL, no JS loop)
      SELECT
        SUM(CASE WHEN sla_status = 'OK' THEN 1 ELSE 0 END)       AS on_track,
        SUM(CASE WHEN sla_status = 'WARNING' THEN 1 ELSE 0 END)  AS at_risk,
        SUM(CASE WHEN sla_status = 'BREACHED' THEN 1 ELSE 0 END) AS breached,
        SUM(CASE WHEN sla_status = 'NO_SLA' THEN 1 ELSE 0 END)   AS no_sla,
        COUNT(*) AS total
      FROM (
        SELECT
          CASE
            WHEN t.due_date IS NULL THEN 'NO_SLA'
            WHEN GETDATE() > t.due_date AND ts2.is_final_status = 0 THEN 'BREACHED'
            WHEN ts2.is_final_status = 1 AND t.resolved_at IS NOT NULL AND t.resolved_at <= t.due_date THEN 'OK'
            WHEN ts2.is_final_status = 1 AND t.resolved_at IS NOT NULL AND t.resolved_at > t.due_date THEN 'BREACHED'
            WHEN DATEDIFF(SECOND, t.created_at, GETDATE()) >= DATEDIFF(SECOND, t.created_at, t.due_date) * 0.8 THEN 'WARNING'
            ELSE 'OK'
          END AS sla_status
        FROM tickets t
        INNER JOIN ticket_statuses ts2 ON t.status_id = ts2.status_id
        WHERE ${ticketWhere}
      ) sla;

      -- 4) Escalated count (open only)
      SELECT COUNT(*) AS cnt
      FROM tickets t
      INNER JOIN ticket_statuses ts ON t.status_id = ts.status_id
      WHERE ${ticketWhere}
        AND t.is_escalated = 1
        AND ts.is_final_status = 0;

      -- 5) My assigned (open)
      SELECT COUNT(*) AS cnt
      FROM tickets t
      INNER JOIN ticket_statuses ts ON t.status_id = ts.status_id
      WHERE t.assigned_to = @userId AND ts.is_final_status = 0;

      -- 6) Total active users (admins only)
      SELECT COUNT(*) AS cnt FROM users WHERE is_active = 1;

      -- 7) Recent tickets (last 10)
      SELECT TOP 10
        t.ticket_id,
        t.ticket_number,
        t.subject,
        t.created_at,
        t.due_date,
        tc.category_name,
        tp.priority_name,
        tp.priority_code,
        ts.status_name,
        ts.status_code,
        u.first_name + ' ' + u.last_name AS requester_name,
        a.first_name + ' ' + a.last_name AS assigned_name
      FROM tickets t
      LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
      LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
      LEFT JOIN ticket_statuses ts ON t.status_id = ts.status_id
      LEFT JOIN users u ON t.requester_id = u.user_id
      LEFT JOIN users a ON t.assigned_to = a.user_id
      WHERE ${ticketWhere}
      ORDER BY t.created_at DESC;

      -- 8) Ticket trend — last 7 days
      SELECT
        CAST(t.created_at AS DATE) AS date_key,
        COUNT(*)                   AS created_count,
        SUM(CASE WHEN ts.is_final_status = 1 THEN 1 ELSE 0 END) AS closed_count
      FROM tickets t
      INNER JOIN ticket_statuses ts ON t.status_id = ts.status_id
      WHERE t.created_at >= DATEADD(DAY, -6, CAST(GETDATE() AS DATE))
        AND ${ticketWhere}
      GROUP BY CAST(t.created_at AS DATE)
      ORDER BY date_key;

      -- 9) Department distribution (open tickets)
      SELECT
        d.department_name,
        COUNT(t.ticket_id) AS cnt
      FROM departments d
      LEFT JOIN tickets t ON d.department_id = t.department_id AND ${ticketWhere}
        AND t.status_id IN (SELECT status_id FROM ticket_statuses WHERE is_final_status = 0)
      WHERE ISNULL(d.is_active, 1) = 1
      GROUP BY d.department_name
      HAVING COUNT(t.ticket_id) > 0
      ORDER BY cnt DESC;

      -- 10) Top performers (last 30 days)
      SELECT TOP 5
        u.first_name + ' ' + u.last_name AS agent_name,
        COUNT(t.ticket_id) AS resolved_count,
        AVG(DATEDIFF(HOUR, t.created_at, COALESCE(t.closed_at, t.resolved_at))) AS avg_hours
      FROM users u
      INNER JOIN tickets t ON u.user_id = t.assigned_to
      INNER JOIN ticket_statuses ts ON t.status_id = ts.status_id
      WHERE ts.is_final_status = 1
        AND (t.closed_at IS NOT NULL OR t.resolved_at IS NOT NULL)
        AND t.created_at >= DATEADD(DAY, -30, GETDATE())
      GROUP BY u.first_name, u.last_name
      HAVING COUNT(t.ticket_id) > 0
      ORDER BY resolved_count DESC;
    `;

    const result = await executeQuery(mainQuery, params);

    // ── Parse recordsets ──
    const statusRows      = result.recordsets[0];
    const priorityRows    = result.recordsets[1];
    const slaRow          = result.recordsets[2][0];
    const escalatedCount  = result.recordsets[3][0]?.cnt || 0;
    const myAssigned      = result.recordsets[4][0]?.cnt || 0;
    const totalUsers      = result.recordsets[5][0]?.cnt || 0;
    const recentTickets   = result.recordsets[6];
    const trendRows       = result.recordsets[7];
    const deptRows        = result.recordsets[8];
    const topPerformers   = result.recordsets[9];

    // ── Build status map ──
    const statusMap = {};
    let totalTickets = 0;
    statusRows.forEach(r => { statusMap[r.status_code] = r.cnt; totalTickets += r.cnt; });

    // ── SLA compliance ──
    const onTrack  = slaRow?.on_track  || 0;
    const atRisk   = slaRow?.at_risk   || 0;
    const breached = slaRow?.breached  || 0;
    const noSla    = slaRow?.no_sla    || 0;
    const totalWithSla = onTrack + atRisk + breached;
    const complianceRate = totalWithSla > 0
      ? parseFloat(((onTrack + atRisk) / totalWithSla * 100).toFixed(1))
      : 0;

    // ── Fill 7-day trend (fill missing dates with 0) ──
    const trend = [];
    for (let i = 6; i >= 0; i--) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const key = d.toISOString().slice(0, 10);
      const row = trendRows.find(r => {
        const rKey = new Date(r.date_key).toISOString().slice(0, 10);
        return rKey === key;
      });
      trend.push({
        date: key,
        day: d.toLocaleDateString('en-US', { weekday: 'short' }),
        created: row?.created_count || 0,
        closed: row?.closed_count || 0,
      });
    }

    // ── Compute comparison vs yesterday ──
    const todayCreated = trend[trend.length - 1]?.created || 0;
    const yesterdayCreated = trend[trend.length - 2]?.created || 0;
    const trendDirection = todayCreated > yesterdayCreated ? 'up' :
                           todayCreated < yesterdayCreated ? 'down' : 'flat';
    const trendPercent = yesterdayCreated > 0
      ? Math.round(Math.abs(todayCreated - yesterdayCreated) / yesterdayCreated * 100)
      : 0;

    // ── Build response ──
    const dashboardData = {
      summary: {
        totalTickets,
        openTickets: statusMap['OPEN'] || 0,
        inProgressTickets: statusMap['IN_PROGRESS'] || 0,
        pendingTickets: statusMap['PENDING'] || 0,
        onHoldTickets: statusMap['ON_HOLD'] || 0,
        closedTickets: (statusMap['CLOSED'] || 0) + (statusMap['RESOLVED'] || 0),
        cancelledTickets: statusMap['CANCELLED'] || 0,
        escalatedTickets: escalatedCount,
        totalUsers: canViewAll ? totalUsers : null,
        myAssignedTickets: myAssigned,
        slaStats: { onTrack, atRisk, breached, noSla, total: slaRow?.total || 0, complianceRate },
        trendDirection,
        trendPercent,
        todayCreated,
      },
      recentTickets,
      ticketsByStatus: statusRows.map(r => ({ label: r.status_name, value: r.cnt, code: r.status_code })),
      ticketsByPriority: priorityRows.map(r => ({ label: r.priority_name, value: r.cnt, code: r.priority_code })),
      trend,
      departmentLoad: deptRows.map(r => ({ name: r.department_name, count: r.cnt })),
      topPerformers: topPerformers.map(r => ({
        name: r.agent_name,
        resolved: r.resolved_count,
        avgHours: Math.round(r.avg_hours || 0),
      })),
      userPermissions: {
        canViewAll,
        canCreateTickets: req.user.permissions?.can_create_tickets || false,
        canManageUsers: req.user.permissions?.can_manage_users || false,
        canViewAnalytics: req.user.permissions?.can_view_analytics || false,
      },
    };

    logger.success('Dashboard stats fetched');

    return res.status(200).json(
      createResponse(true, 'Dashboard statistics fetched successfully', dashboardData)
    );
  } catch (error) {
    logger.error('Dashboard stats error', error);
    next(error);
  }
};

/**
 * Get Recent Activity Feed
 * @route GET /api/v1/dashboard/activity
 * @access Private
 */
const getUserActivity = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const canViewAll = req.user.permissions?.can_view_all_tickets || false;
    const limit = Math.min(parseInt(req.query.limit) || 15, 50);

    const filter = canViewAll
      ? '1=1'
      : '(t.requester_id = @userId OR t.assigned_to = @userId)';

    const query = `
      SELECT TOP (@limit)
        ta.activity_id,
        ta.activity_type,
        ta.description,
        ta.performed_at,
        u.first_name + ' ' + u.last_name AS performed_by_name,
        t.ticket_number,
        t.subject AS ticket_subject
      FROM ticket_activities ta
      INNER JOIN tickets t ON ta.ticket_id = t.ticket_id
      INNER JOIN users u ON ta.performed_by = u.user_id
      WHERE ${filter}
      ORDER BY ta.performed_at DESC
    `;

    const result = await executeQuery(query, { userId, limit });

    return res.status(200).json(
      createResponse(true, 'Activity feed fetched successfully', result.recordset)
    );
  } catch (error) {
    logger.error('User activity error', error);
    next(error);
  }
};

module.exports = {
  getDashboardStats,
  getUserActivity,
};
