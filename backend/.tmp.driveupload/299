// ============================================
// AUTHENTICATION CONTROLLER - UPDATED WITH PASSWORD EXPIRY CHECK
// Handles user authentication and session management
// Developer: Suvadip Panja
// Created: October 11, 2024
// Updated: January 25, 2026 - Added password expiry check during login
// Previous Update: November 11, 2025 - Added 2FA Login Integration
// ============================================

const crypto = require('crypto');
const { executeQuery, executeProcedure } = require('../config/database');
const { 
  comparePassword, 
  generateToken, 
  createResponse,
  hashPassword,
} = require('../utils/helpers');
const logger = require('../utils/logger');
const config = require('../config/config');
const { createNotification } = require('./notifications.controller');
const securityService = require('../services/security.service');
const twoFactorService = require('../services/twoFactor.service'); // ⭐ 2FA Service

/**
 * User Login - UPDATED WITH PASSWORD EXPIRY CHECK
 * @route POST /api/v1/auth/login
 * @access Public
 * @description Authenticates user, checks password expiry, and checks if 2FA is required
 * @updated January 25, 2026 - Added password expiry check during login
 */
const login = async (req, res, next) => {
  try {
    const { username, password } = req.body;
    const ip = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('user-agent');

    logger.separator('USER LOGIN ATTEMPT');
    logger.try('User attempting to login', {
      username,
      ip,
      userAgent,
    });

    // ============================================
    // STEP 1: CHECK IF USER EXISTS
    // ============================================
    logger.try('Checking if user exists in database');
    
    const userQuery = `
      SELECT 
        u.user_id,
        u.username,
        u.email,
        u.password_hash,
        u.first_name,
        u.last_name,
        u.is_active,
        u.is_locked,
        u.failed_login_attempts,
        u.role_id,
        u.department_id,
        r.role_name,
        r.role_code,
        r.can_create_tickets,
        r.can_view_all_tickets,
        r.can_assign_tickets,
        r.can_close_tickets,
        r.can_delete_tickets,
        r.can_manage_users,
        r.can_manage_departments,
        r.can_manage_roles,
        r.can_view_analytics,
        r.can_manage_system,
        d.department_name
      FROM users u
      LEFT JOIN user_roles r ON u.role_id = r.role_id
      LEFT JOIN departments d ON u.department_id = d.department_id
      WHERE u.username = @username OR u.email = @username
    `;

    const userResult = await executeQuery(userQuery, { username });

    if (userResult.recordset.length === 0) {
      logger.warn('Login failed - User not found', { username, ip });
      
      // Log failed login attempt with null userId
      await securityService.logLoginAttempt(username, null, ip, userAgent, false, 'USER_NOT_FOUND');
      
      logger.separator();
      return res.status(401).json(
        createResponse(false, 'Invalid username or password')
      );
    }

    const user = userResult.recordset[0];
    logger.success('User found in database', { userId: user.user_id });

    // ============================================
    // STEP 2: CHECK IF USER IS ACTIVE
    // ============================================
    if (!user.is_active) {
      logger.warn('Login failed - User account is inactive', {
        userId: user.user_id,
        username: user.username,
        ip,
      });
      
      await securityService.logLoginAttempt(username, user.user_id, ip, userAgent, false, 'ACCOUNT_INACTIVE');
      
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'Your account has been deactivated. Please contact administrator.')
      );
    }

    logger.success('User account is active');

    // ============================================
    // STEP 3: CHECK IF ACCOUNT IS LOCKED
    // ============================================
    logger.try('Checking account lockout status');
    
    const lockStatus = await securityService.checkAccountLockout(user.user_id);
    
    if (lockStatus.locked) {
      logger.warn('Login failed - Account is locked', {
        userId: user.user_id,
        username: user.username,
        ip,
        minutesRemaining: lockStatus.minutesRemaining,
        permanent: lockStatus.permanent
      });
      
      await securityService.logLoginAttempt(username, user.user_id, ip, userAgent, false, 'ACCOUNT_LOCKED');
      
      logger.separator();
      
      const message = lockStatus.permanent
        ? 'Your account has been locked. Please contact administrator.'
        : `Your account is locked. Please try again in ${lockStatus.minutesRemaining} minutes.`;
      
      return res.status(403).json(
        createResponse(false, message)
      );
    }

    logger.success('Account is not locked');

    // ============================================
    // STEP 4: VERIFY PASSWORD
    // ============================================
    logger.try('Verifying password');
    
    const isPasswordValid = await comparePassword(password, user.password_hash);

    if (!isPasswordValid) {
      // Handle failed login
      const failedStatus = await securityService.handleFailedLogin(
        user.user_id,
        user.username,
        ip
      );

      logger.warn('Login failed - Invalid password', {
        userId: user.user_id,
        username: user.username,
        attempts: failedStatus.attempts,
        remaining: failedStatus.remaining,
        locked: failedStatus.locked,
        ip,
      });

      // Log failed login attempt
      await securityService.logLoginAttempt(username, user.user_id, ip, userAgent, false, 'INVALID_PASSWORD');

      logger.separator();
      
      if (failedStatus.locked) {
        return res.status(401).json(
          createResponse(
            false,
            'Account locked for 30 minutes due to multiple failed login attempts.'
          )
        );
      } else {
        return res.status(401).json(
          createResponse(
            false,
            `Invalid username or password. ${failedStatus.remaining} attempts remaining.`
          )
        );
      }
    }

    logger.success('Password verified successfully');

    // ============================================
    // STEP 5: RESET FAILED LOGIN ATTEMPTS
    // ============================================
    logger.info('Resetting failed login attempts');
    await securityService.resetFailedLoginAttempts(user.user_id);

    // ============================================
    // ⭐ STEP 5A: CHECK PASSWORD EXPIRY (NEW - CRITICAL FIX)
    // This prevents users with expired passwords from logging in
    // ============================================
    logger.try('Checking password expiry status');
    
    const expiryStatus = await securityService.checkPasswordExpiry(user.user_id);
    
    if (expiryStatus.expired) {
      const daysExpired = Math.abs(expiryStatus.daysRemaining);
      
      logger.warn('Login failed - Password has expired', {
        userId: user.user_id,
        username: user.username,
        passwordExpiresAt: expiryStatus.passwordExpiresAt,
        daysExpired: daysExpired,
        ip
      });
      
      // Log failed login attempt due to password expiry
      await securityService.logLoginAttempt(
        username, 
        user.user_id, 
        ip, 
        userAgent, 
        false, 
        'PASSWORD_EXPIRED'
      );
      
      // Log security event
      await securityService.logSecurityEvent(
        user.user_id,
        'LOGIN_FAILED_PASSWORD_EXPIRED',
        `Login attempt failed - Password expired ${daysExpired} days ago`,
        ip,
        userAgent,
        false
      );
      
      logger.separator();
      
      // Return detailed error message to frontend
      return res.status(401).json(
        createResponse(false, 'Your password has expired. Please contact your administrator to reset your password.', {
          passwordExpired: true,
          daysExpired: daysExpired,
          expiredAt: expiryStatus.passwordExpiresAt,
          requiresReset: true
        })
      );
    }
    
    // Check if password is expiring soon (warning)
    if (expiryStatus.isWarning) {
      logger.warn('Password expiring soon', {
        userId: user.user_id,
        username: user.username,
        daysRemaining: expiryStatus.daysRemaining
      });
      
      // We'll allow login but inform the user after successful login
      // This will be handled in the response data
    }
    
    logger.success('Password expiry check passed');

    // ============================================
    // STEP 6: CHECK IF 2FA IS ENABLED
    // ============================================
    logger.try('Checking if 2FA is enabled for user');
    
    const is2FAEnabled = await twoFactorService.is2FAEnabled(user.user_id);
    
    if (is2FAEnabled) {
      logger.info('2FA is enabled for user, initiating 2FA flow', {
        userId: user.user_id,
        email: user.email
      });
      
      // ⭐ Send OTP to user's email
      logger.try('Sending OTP to user email');
      
      try {
        const otpResult = await twoFactorService.sendOTPEmail(
          user.user_id,
          user.email,
          `${user.first_name} ${user.last_name}`
        );
        
        logger.success('OTP sent successfully', {
          userId: user.user_id,
          expiryMinutes: otpResult.expiryMinutes
        });
        
        // Log partial login (password verified, waiting for OTP)
        await securityService.logSecurityEvent(
          user.user_id,
          'LOGIN_2FA_INITIATED',
          'Password verified, 2FA OTP sent to email',
          ip,
          userAgent,
          true
        );
        
        logger.separator();
        
        // ⭐ RETURN WITHOUT JWT TOKEN
        // Frontend will show OTP input screen
        return res.status(200).json(
          createResponse(true, 'Verification code sent to your email', {
            requiresTwoFactor: true,
            userId: user.user_id,
            email: user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3'), // Masked email
            expiryMinutes: otpResult.expiryMinutes,
            // Include password expiry warning if applicable
            passwordExpiryWarning: expiryStatus.isWarning ? {
              daysRemaining: expiryStatus.daysRemaining,
              expiresAt: expiryStatus.passwordExpiresAt
            } : null
          })
        );
        
      } catch (otpError) {
        logger.error('Failed to send OTP email', otpError);
        
        // If OTP sending fails, still allow login without 2FA
        // (Graceful degradation)
        logger.warn('2FA email send failed, continuing normal login');
        
        // Continue to normal login below...
      }
    }
    
    logger.info('2FA not enabled, continuing normal login');

    // ============================================
    // STEP 7: CHECK CONCURRENT SESSIONS
    // ============================================
    logger.try('Checking concurrent sessions limit');
    const sessionStatus = await securityService.checkConcurrentSessions(user.user_id);
    
    if (!sessionStatus.allowed) {
      logger.warn('Concurrent session limit reached, invalidating oldest session', {
        userId: user.user_id,
        currentSessions: sessionStatus.currentSessions,
        maxSessions: sessionStatus.maxSessions
      });
      
      // Invalidate oldest session to make room
      await securityService.invalidateOldestSession(user.user_id);
    }

    // ============================================
    // STEP 8: GENERATE JWT TOKEN
    // ============================================
    logger.try('Generating JWT token');
    
    const tokenPayload = {
      user_id: user.user_id,
      username: user.username,
      email: user.email,
      role_code: user.role_code,
    };

    const token = generateToken(tokenPayload, config.jwt.expire);
    
    logger.success('JWT token generated successfully');

    // ============================================
    // STEP 9: CREATE SESSION RECORD
    // ============================================
    logger.try('Creating user session record');
    
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 8); // 8 hours from now

    const sessionQuery = `
      INSERT INTO user_sessions (
        user_id, token_hash, ip_address, user_agent,
        expires_at, is_active
      )
      VALUES (
        @userId, @tokenHash, @ipAddress, @userAgent,
        @expiresAt, 1
      )
    `;

    await executeQuery(sessionQuery, {
      userId: user.user_id,
      tokenHash,
      ipAddress: ip,
      userAgent,
      expiresAt,
    });

    logger.success('Session record created');

    // ============================================
    // STEP 10: UPDATE LAST LOGIN TIME
    // ============================================
    logger.try('Updating last login timestamp');
    
    await executeQuery(
      'UPDATE users SET last_login = GETDATE() WHERE user_id = @userId',
      { userId: user.user_id }
    );

    logger.success('Last login timestamp updated');

    // ============================================
    // STEP 11: LOG SUCCESSFUL LOGIN
    // ============================================
    await securityService.logLoginAttempt(username, user.user_id, ip, userAgent, true, null);
    await securityService.logSecurityEvent(
      user.user_id,
      'LOGIN_SUCCESS',
      'User logged in successfully',
      ip,
      userAgent,
      true
    );

    // ============================================
    // STEP 12: CREATE LOGIN NOTIFICATION
    // ============================================
    logger.try('Creating login notification');
    
    await createNotification(
      user.user_id,
      'LOGIN',
      'New Login',
      `User "${user.username}" logged in successfully from ${ip || '::1'}`,
      null
    );
	
    logger.success('Login notification created');

    // ============================================
    // STEP 13: PREPARE RESPONSE DATA
    // ============================================
    const userData = {
      user_id: user.user_id,
      username: user.username,
      email: user.email,
      first_name: user.first_name,
      last_name: user.last_name,
      full_name: `${user.first_name} ${user.last_name}`,
      role: {
        role_id: user.role_id,
        role_name: user.role_name,
        role_code: user.role_code,
      },
      department: user.department_id ? {
        department_id: user.department_id,
        department_name: user.department_name,
      } : null,
      permissions: {
        can_create_tickets: user.can_create_tickets,
        can_view_all_tickets: user.can_view_all_tickets,
        can_assign_tickets: user.can_assign_tickets,
        can_close_tickets: user.can_close_tickets,
        can_delete_tickets: user.can_delete_tickets,
        can_manage_users: user.can_manage_users,
        can_manage_departments: user.can_manage_departments,
        can_manage_roles: user.can_manage_roles,
        can_view_analytics: user.can_view_analytics,
        can_manage_system: user.can_manage_system,
      },
      // ⭐ Include password expiry warning if applicable
      passwordExpiryWarning: expiryStatus.isWarning ? {
        daysRemaining: expiryStatus.daysRemaining,
        expiresAt: expiryStatus.passwordExpiresAt,
        message: `Your password will expire in ${expiryStatus.daysRemaining} days. Please change it soon.`
      } : null
    };

    logger.separator('LOGIN SUCCESSFUL');
    logger.success('User logged in successfully', {
      userId: user.user_id,
      username: user.username,
      ip,
    });
    logger.separator();

    // ============================================
    // STEP 14: RETURN SUCCESS RESPONSE
    // ============================================
    return res.status(200).json(
      createResponse(true, 'Login successful', {
        token,
        user: userData,
      })
    );
  } catch (error) {
    logger.error('Login controller error', error);
    logger.separator();
    next(error);
  }
};

/**
 * ⭐ Verify 2FA OTP During Login
 * @route POST /api/v1/auth/verify-2fa-login
 * @access Public (but requires valid userId and OTP)
 * @description Verifies OTP code and completes login process
 * @created November 11, 2025
 */
const verifyTwoFactorLogin = async (req, res, next) => {
  try {
    const { userId, code } = req.body;
    const ip = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('user-agent');

    logger.separator('2FA OTP VERIFICATION');
    logger.try('Verifying 2FA OTP for login', { userId, ip });

    // ============================================
    // STEP 1: VALIDATE INPUT
    // ============================================
    if (!userId || !code) {
      logger.warn('Missing required fields', { userId: !!userId, code: !!code });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'User ID and verification code are required')
      );
    }

    // ============================================
    // STEP 2: VERIFY OTP CODE
    // ============================================
    logger.try('Verifying OTP code');
    
    const verificationResult = await twoFactorService.verify2FA(
      userId,
      code,
      'email'
    );

    if (!verificationResult.success) {
      logger.warn('OTP verification failed', {
        userId,
        message: verificationResult.message
      });
      
      // Log failed 2FA attempt
      await securityService.logSecurityEvent(
        userId,
        'LOGIN_2FA_FAILED',
        `2FA verification failed: ${verificationResult.message}`,
        ip,
        userAgent,
        false
      );
      
      logger.separator();
      return res.status(401).json(
        createResponse(false, verificationResult.message)
      );
    }

    logger.success('OTP verified successfully');

    // ============================================
    // STEP 3: FETCH USER DATA
    // ============================================
    logger.try('Fetching user data for session creation');
    
    const userQuery = `
      SELECT 
        u.user_id,
        u.username,
        u.email,
        u.first_name,
        u.last_name,
        u.is_active,
        u.role_id,
        u.department_id,
        r.role_name,
        r.role_code,
        r.can_create_tickets,
        r.can_view_all_tickets,
        r.can_assign_tickets,
        r.can_close_tickets,
        r.can_delete_tickets,
        r.can_manage_users,
        r.can_manage_departments,
        r.can_manage_roles,
        r.can_view_analytics,
        r.can_manage_system,
        d.department_name
      FROM users u
      LEFT JOIN user_roles r ON u.role_id = r.role_id
      LEFT JOIN departments d ON u.department_id = d.department_id
      WHERE u.user_id = @userId
    `;

    const userResult = await executeQuery(userQuery, { userId });

    if (userResult.recordset.length === 0) {
      logger.error('User not found after 2FA verification', { userId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'User not found')
      );
    }

    const user = userResult.recordset[0];
    logger.success('User data fetched successfully');

    // ============================================
    // STEP 4: GENERATE JWT TOKEN
    // ============================================
    logger.try('Generating JWT token');
    
    const tokenPayload = {
      user_id: user.user_id,
      username: user.username,
      email: user.email,
      role_code: user.role_code,
    };

    const token = generateToken(tokenPayload, config.jwt.expire);
    
    logger.success('JWT token generated successfully');

    // ============================================
    // STEP 5: CREATE SESSION RECORD
    // ============================================
    logger.try('Creating user session record');
    
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 8);

    const sessionQuery = `
      INSERT INTO user_sessions (
        user_id, token_hash, ip_address, user_agent,
        expires_at, is_active
      )
      VALUES (
        @userId, @tokenHash, @ipAddress, @userAgent,
        @expiresAt, 1
      )
    `;

    await executeQuery(sessionQuery, {
      userId: user.user_id,
      tokenHash,
      ipAddress: ip,
      userAgent,
      expiresAt,
    });

    logger.success('Session created');

    // ============================================
    // STEP 6: UPDATE LAST LOGIN
    // ============================================
    logger.try('Updating last login timestamp');
    
    await executeQuery(
      'UPDATE users SET last_login = GETDATE() WHERE user_id = @userId',
      { userId: user.user_id }
    );

    logger.success('Last login updated');

    // ============================================
    // STEP 7: LOG SUCCESSFUL LOGIN
    // ============================================
    await securityService.logLoginAttempt(user.username, user.user_id, ip, userAgent, true, null);
    await securityService.logSecurityEvent(
      user.user_id,
      'LOGIN_2FA_SUCCESS',
      'User logged in successfully after 2FA verification',
      ip,
      userAgent,
      true
    );

    // ============================================
    // STEP 8: CREATE LOGIN NOTIFICATION
    // ============================================
    logger.try('Creating login notification');
    
    await createNotification(
      user.user_id,
      'LOGIN',
      'New Login (2FA)',
      `User "${user.username}" logged in successfully with 2FA from ${ip || '::1'}`,
      null
    );
	
    logger.success('Login notification created');

    // ============================================
    // STEP 9: PREPARE RESPONSE DATA
    // ============================================
    const userData = {
      user_id: user.user_id,
      username: user.username,
      email: user.email,
      first_name: user.first_name,
      last_name: user.last_name,
      full_name: `${user.first_name} ${user.last_name}`,
      role: {
        role_id: user.role_id,
        role_name: user.role_name,
        role_code: user.role_code,
      },
      department: user.department_id ? {
        department_id: user.department_id,
        department_name: user.department_name,
      } : null,
      permissions: {
        can_create_tickets: user.can_create_tickets,
        can_view_all_tickets: user.can_view_all_tickets,
        can_assign_tickets: user.can_assign_tickets,
        can_close_tickets: user.can_close_tickets,
        can_delete_tickets: user.can_delete_tickets,
        can_manage_users: user.can_manage_users,
        can_manage_departments: user.can_manage_departments,
        can_manage_roles: user.can_manage_roles,
        can_view_analytics: user.can_view_analytics,
        can_manage_system: user.can_manage_system,
      },
    };

    logger.separator('2FA LOGIN SUCCESSFUL');
    logger.success('User logged in with 2FA', {
      userId: user.user_id,
      username: user.username,
      ip,
    });
    logger.separator();

    // ============================================
    // STEP 10: RETURN SUCCESS RESPONSE
    // ============================================
    return res.status(200).json(
      createResponse(true, 'Login successful', {
        token,
        user: userData,
      })
    );

  } catch (error) {
    logger.error('2FA login verification error', error);
    logger.separator();
    next(error);
  }
};

/**
 * User Logout
 * @route POST /api/v1/auth/logout
 * @access Private
 */
const logout = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const token = req.headers.authorization?.split(' ')[1];

    logger.separator('USER LOGOUT');
    logger.try('User attempting to logout', { userId });

    if (token) {
      // Invalidate session
      const tokenHash = crypto.createHash('sha256').update(token).digest('hex');
      
      await executeQuery(
        'UPDATE user_sessions SET is_active = 0 WHERE token_hash = @tokenHash',
        { tokenHash }
      );

      logger.success('Session invalidated');
    }

    // Log security event
    await securityService.logSecurityEvent(
      userId,
      'LOGOUT',
      'User logged out successfully',
      req.ip,
      req.get('user-agent'),
      true
    );

    logger.success('User logged out successfully', { userId });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Logout successful')
    );
  } catch (error) {
    logger.error('Logout controller error', error);
    next(error);
  }
};

/**
 * Get Current User Profile
 * @route GET /api/v1/auth/me
 * @access Private
 */
const getMe = async (req, res, next) => {
  try {
    logger.separator('GET USER PROFILE');
    logger.try('Fetching user profile', { userId: req.user.user_id });

    const userQuery = `
      SELECT 
        u.user_id,
        u.username,
        u.email,
        u.first_name,
        u.last_name,
        u.phone_number,
        u.profile_picture,
        u.last_login,
        u.created_at,
        u.role_id,
        u.department_id,
        r.role_name,
        r.role_code,
        r.can_create_tickets,
        r.can_view_all_tickets,
        r.can_assign_tickets,
        r.can_close_tickets,
        r.can_delete_tickets,
        r.can_manage_users,
        r.can_manage_departments,
        r.can_manage_roles,
        r.can_view_analytics,
        r.can_manage_system,
        d.department_id,
        d.department_name,
        d.department_code
      FROM users u
      LEFT JOIN user_roles r ON u.role_id = r.role_id
      LEFT JOIN departments d ON u.department_id = d.department_id
      WHERE u.user_id = @userId
    `;

    const result = await executeQuery(userQuery, {
      userId: req.user.user_id,
    });

    if (result.recordset.length === 0) {
      logger.warn('User not found', { userId: req.user.user_id });
      return res.status(404).json(
        createResponse(false, 'User not found')
      );
    }

    const user = result.recordset[0];

    const userData = {
      user_id: user.user_id,
      username: user.username,
      email: user.email,
      first_name: user.first_name,
      last_name: user.last_name,
      full_name: `${user.first_name} ${user.last_name}`,
      phone_number: user.phone_number,
      profile_picture: user.profile_picture,
      last_login: user.last_login,
      created_at: user.created_at,
      role: {
        role_id: user.role_id,
        role_name: user.role_name,
        role_code: user.role_code,
      },
      department: user.department_id ? {
        department_id: user.department_id,
        department_name: user.department_name,
        department_code: user.department_code,
      } : null,
      permissions: {
        can_create_tickets: user.can_create_tickets,
        can_view_all_tickets: user.can_view_all_tickets,
        can_assign_tickets: user.can_assign_tickets,
        can_close_tickets: user.can_close_tickets,
        can_delete_tickets: user.can_delete_tickets,
        can_manage_users: user.can_manage_users,
        can_manage_departments: user.can_manage_departments,
        can_manage_roles: user.can_manage_roles,
        can_view_analytics: user.can_view_analytics,
        can_manage_system: user.can_manage_system,
      },
    };

    logger.success('User profile fetched successfully', {
      userId: user.user_id,
      username: user.username,
    });

    return res.status(200).json(
      createResponse(true, 'User profile fetched successfully', userData)
    );
  } catch (error) {
    logger.error('Get me controller error', error);
    next(error);
  }
};

/**
 * Change Password - SECURITY ENHANCED
 * @route PUT /api/v1/auth/change-password
 * @access Private
 */
const changePassword = async (req, res, next) => {
  try {
    const { current_password, new_password } = req.body;
    const userId = req.user.user_id;

    logger.separator('PASSWORD CHANGE');
    logger.try('User attempting to change password', {
      userId,
      username: req.user.username,
    });

    // Get current password hash
    const userQuery = `
      SELECT password_hash 
      FROM users 
      WHERE user_id = @userId
    `;

    const result = await executeQuery(userQuery, { userId });

    if (result.recordset.length === 0) {
      logger.warn('User not found', { userId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'User not found')
      );
    }

    // Verify current password
    logger.try('Verifying current password');
    
    const isCurrentPasswordValid = await comparePassword(
      current_password,
      result.recordset[0].password_hash
    );

    if (!isCurrentPasswordValid) {
      logger.warn('Current password is incorrect', { userId });
      logger.separator();
      return res.status(401).json(
        createResponse(false, 'Current password is incorrect')
      );
    }

    logger.success('Current password verified');

    // Validate new password against policy
    logger.try('Validating new password against security policy');
    
    const policyValidation = await securityService.validatePasswordPolicy(new_password);
    
    if (!policyValidation.valid) {
      logger.warn('New password does not meet policy requirements', {
        userId,
        errors: policyValidation.errors
      });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Password does not meet security requirements', {
          errors: policyValidation.errors
        })
      );
    }

    logger.success('Password validation passed');

    // Check password history
    logger.try('Checking password history');
    const historyCheck = await securityService.checkPasswordHistory(userId, new_password);
    
    if (!historyCheck.allowed) {
      logger.warn('Password history check failed', { userId });
      logger.separator();
      return res.status(400).json(
        createResponse(false, historyCheck.message)
      );
    }

    logger.success('Password history check passed');

    // Hash new password
    logger.try('Hashing new password');
    
    const newPasswordHash = await hashPassword(new_password);
    
    logger.success('New password hashed');

    // Update password
    logger.try('Updating password in database');
    
    const updateQuery = `
      UPDATE users
      SET 
        password_hash = @passwordHash,
        updated_at = GETDATE(),
        updated_by = @userId
      WHERE user_id = @userId
    `;

    await executeQuery(updateQuery, {
      passwordHash: newPasswordHash,
      userId,
    });

    logger.success('Password updated successfully');

    // Save password to history
    logger.try('Saving password to history');
    await securityService.savePasswordHistory(userId, newPasswordHash, userId, 'MANUAL');
    logger.success('Password saved to history');

    // Update password expiry date
    logger.try('Updating password expiry date');
    await securityService.updatePasswordExpiryDate(userId);
    logger.success('Password expiry date updated');

    // Invalidate all sessions except current
    logger.try('Invalidating all other sessions');
    
    const currentToken = req.headers.authorization?.split(' ')[1];
    const currentTokenHash = currentToken 
      ? crypto.createHash('sha256').update(currentToken).digest('hex')
      : null;

    const invalidateQuery = `
      UPDATE user_sessions
      SET is_active = 0
      WHERE user_id = @userId
      ${currentTokenHash ? 'AND token_hash != @tokenHash' : ''}
    `;

    await executeQuery(invalidateQuery, {
      userId,
      tokenHash: currentTokenHash,
    });

    logger.success('Other sessions invalidated');

    // Log security event
    await securityService.logSecurityEvent(
      userId,
      'PASSWORD_CHANGED',
      'User changed password successfully',
      req.ip,
      req.get('user-agent'),
      true
    );

    // Create notification
    await createNotification(
      userId,
      'SECURITY',
      'Password Changed',
      'Your password has been changed successfully. All other sessions have been logged out.',
      null
    );

    logger.separator('PASSWORD CHANGE SUCCESSFUL');
    logger.success('Password changed successfully', { userId });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Password changed successfully. All other sessions have been logged out.')
    );
  } catch (error) {
    logger.error('Change password controller error', error);
    logger.separator();
    next(error);
  }
};

// ============================================
// EXPORTS
// ============================================
module.exports = {
  login,
  verifyTwoFactorLogin,
  logout,
  getMe,
  changePassword,
};