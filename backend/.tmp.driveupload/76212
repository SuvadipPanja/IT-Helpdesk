// ============================================
// BACKUP CONTROLLER - COMPLETE FINAL VERSION
// Handles all backup-related API requests
// Developer: Suvadip Panja
// Date: January 31, 2026
// FILE: backend/controllers/backup.controller.js
// ============================================

const backupService = require('../services/backup.service');
const settingsService = require('../services/settings.service');
const emailQueueService = require('../services/emailQueue.service');
const logger = require('../utils/logger');
const { createResponse } = require('../utils/helpers');
const { executeQuery } = require('../config/database');
const archiver = require('archiver');
const path = require('path');
const fs = require('fs');

// ============================================
// CREATE MANUAL BACKUP
// POST /api/v1/backup/create
// @access Private (Admin only)
// ============================================
const createBackup = async (req, res, next) => {
  try {
    const userId = req.user.userId;

    logger.try('Creating manual backup', { userId });

    // Call backup service
    const result = await backupService.createBackup('MANUAL', userId);

    if (!result.success) {
      logger.warn('Manual backup creation failed', { reason: result.message });
      return res.status(400).json(
        createResponse(false, result.message, null)
      );
    }

    logger.success('Manual backup created successfully', {
      backupId: result.data.backupId,
      backupName: result.data.backupName
    });

    // Send email notification if enabled
    try {
      const settings = await settingsService.getByCategory('backup');
      const notificationsEnabled = settings.backup_email_notifications === 'true';

      if (notificationsEnabled && settings.backup_email_recipients) {
        const recipients = settings.backup_email_recipients.split(',').map(email => email.trim());
        
        await emailQueueService.addToQueue({
          to: recipients,
          subject: `Backup Created Successfully - ${result.data.backupName}`,
          templateName: 'backup-notification',
          templateData: {
            backupName: result.data.backupName,
            backupType: 'Manual',
            status: 'COMPLETED',
            size: `${result.data.totalSizeMB} MB`,
            duration: `${result.data.durationSeconds} seconds`,
            createdBy: req.user.username,
            createdAt: new Date().toISOString()
          }
        });

        logger.info('Backup notification email queued');
      }
    } catch (emailError) {
      logger.error('Failed to queue backup notification email', emailError);
      // Don't fail the request if email fails
    }

    return res.status(201).json(
      createResponse(true, 'Backup created successfully', result.data)
    );

  } catch (error) {
    logger.error('Create backup error', error);
    next(error);
  }
};

// ============================================
// GET BACKUP HISTORY
// GET /api/v1/backup/history
// @access Private (Admin/Manager)
// ============================================
const getBackupHistory = async (req, res, next) => {
  try {
    const { page = 1, limit = 10 } = req.query;

    logger.try('Getting backup history', { page, limit });

    const result = await backupService.getBackupHistory(page, limit);

    logger.success('Backup history retrieved', {
      totalCount: result.pagination.totalCount,
      currentPage: result.pagination.currentPage
    });

    return res.status(200).json(
      createResponse(true, 'Backup history retrieved successfully', result)
    );

  } catch (error) {
    logger.error('Get backup history error', error);
    next(error);
  }
};

// ============================================
// GET BACKUP STATISTICS
// GET /api/v1/backup/statistics
// @access Private (Admin/Manager)
// ============================================
const getBackupStatistics = async (req, res, next) => {
  try {
    logger.try('Getting backup statistics');

    const stats = await backupService.getBackupStats();

    logger.success('Backup statistics retrieved', {
      totalBackups: stats.totalBackups,
      completedBackups: stats.completedBackups
    });

    return res.status(200).json(
      createResponse(true, 'Backup statistics retrieved successfully', stats)
    );

  } catch (error) {
    logger.error('Get backup statistics error', error);
    next(error);
  }
};

// ============================================
// GET BACKUP BY ID
// GET /api/v1/backup/:backupId
// @access Private (Admin/Manager)
// ============================================
const getBackupById = async (req, res, next) => {
  try {
    const { backupId } = req.params;

    logger.try('Getting backup by ID', { backupId });

    const query = `
      SELECT 
        bh.backup_id,
        bh.backup_name,
        bh.backup_type,
        bh.backup_trigger,
        bh.backup_path,
        bh.database_backup_path,
        bh.files_backup_path,
        bh.status,
        bh.started_at,
        bh.completed_at,
        bh.duration_seconds,
        bh.database_size_mb,
        bh.files_size_mb,
        bh.total_size_mb,
        bh.files_count,
        bh.error_message,
        bh.created_at,
        bh.created_by,
        u.username as created_by_name,
        u.email as created_by_email
      FROM backup_history bh
      LEFT JOIN users u ON bh.created_by = u.user_id
      WHERE bh.backup_id = @backupId
        AND bh.is_deleted = 0
    `;

    const result = await executeQuery(query, { backupId });

    if (!result.recordset || result.recordset.length === 0) {
      logger.warn('Backup not found', { backupId });
      return res.status(404).json(
        createResponse(false, 'Backup not found', null)
      );
    }

    const backup = result.recordset[0];

    logger.success('Backup retrieved', {
      backupId,
      backupName: backup.backup_name,
      status: backup.status
    });

    return res.status(200).json(
      createResponse(true, 'Backup retrieved successfully', backup)
    );

  } catch (error) {
    logger.error('Get backup by ID error', error);
    next(error);
  }
};

// ============================================
// DOWNLOAD BACKUP
// GET /api/v1/backup/:backupId/download
// @access Private (Admin only)
// ============================================
const downloadBackup = async (req, res, next) => {
  try {
    const { backupId } = req.params;
    
    logger.try('Downloading backup', { backupId });

    // ============================================
    // STEP 1: GET BACKUP RECORD FROM DATABASE
    // ============================================
    const query = `
      SELECT 
        backup_id,
        backup_name,
        backup_path,
        database_backup_path,
        files_backup_path,
        status,
        total_size_mb
      FROM backup_history
      WHERE backup_id = @backupId
        AND is_deleted = 0
    `;

    const result = await executeQuery(query, { backupId });

    if (!result.recordset || result.recordset.length === 0) {
      logger.warn('Backup not found', { backupId });
      return res.status(404).json(
        createResponse(false, 'Backup not found', null)
      );
    }

    const backup = result.recordset[0];

    // Check if backup completed successfully
    if (backup.status !== 'COMPLETED') {
      logger.warn('Backup not completed', { backupId, status: backup.status });
      return res.status(400).json(
        createResponse(false, 'Backup is not available for download', null)
      );
    }

    logger.info('Backup record retrieved', {
      backupId,
      backupName: backup.backup_name,
      status: backup.status
    });

    // ============================================
    // STEP 2: VERIFY FILES EXIST
    // ============================================
    const databaseBackupPath = backup.database_backup_path;
    const filesBackupPath = backup.files_backup_path;
    const backupPath = backup.backup_path;

    // Check if database backup exists
    if (!fs.existsSync(databaseBackupPath)) {
      logger.error('Database backup file not found', { path: databaseBackupPath });
      return res.status(404).json(
        createResponse(false, 'Database backup file not found', null)
      );
    }

    // Check if files backup folder exists
    if (!fs.existsSync(filesBackupPath)) {
      logger.warn('Files backup folder not found', { path: filesBackupPath });
      // Continue anyway - database backup alone is still useful
    }

    logger.success('Backup files verified', {
      databaseExists: fs.existsSync(databaseBackupPath),
      filesExists: fs.existsSync(filesBackupPath)
    });

    // ============================================
    // STEP 3: CREATE ZIP FILE
    // ============================================
    const zipFileName = `${backup.backup_name}.zip`;
    
    // Set response headers for file download
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename="${zipFileName}"`);

    // Create archiver instance
    const archive = archiver('zip', {
      zlib: { level: 9 } // Maximum compression
    });

    // Handle archiver errors
    archive.on('error', (err) => {
      logger.error('Archive creation error', err);
      if (!res.headersSent) {
        res.status(500).json(
          createResponse(false, 'Failed to create backup archive', null)
        );
      }
    });

    // Handle archiver warnings
    archive.on('warning', (err) => {
      if (err.code === 'ENOENT') {
        logger.warn('Archive warning', err);
      } else {
        logger.error('Archive error', err);
        throw err;
      }
    });

    // Pipe archive to response
    archive.pipe(res);

    logger.try('Creating ZIP archive', { zipFileName });

    // ============================================
    // STEP 4: ADD FILES TO ZIP
    // ============================================

    // Add database backup file
    archive.file(databaseBackupPath, { 
      name: path.basename(databaseBackupPath) 
    });
    logger.info('Added database backup to ZIP', { 
      file: path.basename(databaseBackupPath) 
    });

    // Add files backup folder (if exists)
    if (fs.existsSync(filesBackupPath)) {
      archive.directory(filesBackupPath, 'files');
      logger.info('Added files folder to ZIP', { 
        folder: 'files' 
      });
    }

    // Add metadata.json (if exists)
    const metadataPath = path.join(backupPath, 'metadata.json');
    if (fs.existsSync(metadataPath)) {
      archive.file(metadataPath, { name: 'metadata.json' });
      logger.info('Added metadata to ZIP', { file: 'metadata.json' });
    }

    // ============================================
    // STEP 5: FINALIZE AND SEND
    // ============================================
    await archive.finalize();

    logger.success('Backup downloaded successfully', {
      backupId,
      backupName: backup.backup_name,
      zipFileName
    });

  } catch (error) {
    logger.error('Download backup error', error);
    next(error);
  }
};

// ============================================
// DELETE BACKUP
// DELETE /api/v1/backup/:backupId
// @access Private (Admin only)
// ============================================
const deleteBackup = async (req, res, next) => {
  try {
    const { backupId } = req.params;
    const userId = req.user.userId;

    logger.try('Deleting backup', { backupId, userId });

    // Get backup details first
    const getQuery = `
      SELECT 
        backup_id,
        backup_name,
        database_backup_path,
        files_backup_path,
        backup_path
      FROM backup_history
      WHERE backup_id = @backupId
        AND is_deleted = 0
    `;

    const getResult = await executeQuery(getQuery, { backupId });

    if (!getResult.recordset || getResult.recordset.length === 0) {
      logger.warn('Backup not found for deletion', { backupId });
      return res.status(404).json(
        createResponse(false, 'Backup not found', null)
      );
    }

    const backup = getResult.recordset[0];

    // Mark as deleted in database (soft delete)
    const deleteQuery = `
      UPDATE backup_history
      SET 
        is_deleted = 1,
        deleted_at = GETDATE(),
        deleted_by = @userId
      WHERE backup_id = @backupId
    `;

    await executeQuery(deleteQuery, { backupId, userId });

    logger.info('Backup marked as deleted in database', { backupId });

    // Delete actual files
    try {
      // Delete database backup file
      if (fs.existsSync(backup.database_backup_path)) {
        fs.unlinkSync(backup.database_backup_path);
        logger.info('Deleted database backup file', { 
          path: backup.database_backup_path 
        });
      }

      // Delete backup directory (contains files and metadata)
      if (fs.existsSync(backup.backup_path)) {
        fs.rmSync(backup.backup_path, { recursive: true, force: true });
        logger.info('Deleted backup directory', { 
          path: backup.backup_path 
        });
      }
    } catch (fileError) {
      logger.error('Error deleting backup files', fileError);
      // Don't fail the request if file deletion fails
    }

    logger.success('Backup deleted successfully', {
      backupId,
      backupName: backup.backup_name
    });

    return res.status(200).json(
      createResponse(true, 'Backup deleted successfully', { backupId })
    );

  } catch (error) {
    logger.error('Delete backup error', error);
    next(error);
  }
};

// ============================================
// GET BACKUP CONFIGURATION
// GET /api/v1/backup/config
// @access Private (Admin/Manager)
// ============================================
const getBackupConfig = async (req, res, next) => {
  try {
    logger.try('Getting backup configuration');

    const settings = await settingsService.getByCategory('backup');

    const config = {
      enabled: settings.backup_enabled === 'true',
      frequency: settings.backup_frequency || 'daily',
      time: settings.backup_time || '02:00',
      retentionDays: parseInt(settings.backup_retention_days) || 30,
      emailNotifications: settings.backup_email_notifications === 'true',
      emailRecipients: settings.backup_email_recipients || ''
    };

    logger.success('Backup configuration retrieved');

    return res.status(200).json(
      createResponse(true, 'Backup configuration retrieved successfully', config)
    );

  } catch (error) {
    logger.error('Get backup config error', error);
    next(error);
  }
};

// ============================================
// UPDATE BACKUP CONFIGURATION
// PUT /api/v1/backup/config
// @access Private (Admin only)
// ============================================
const updateBackupConfig = async (req, res, next) => {
  try {
    const { 
      enabled, 
      frequency, 
      time, 
      retentionDays, 
      emailNotifications, 
      emailRecipients 
    } = req.body;
    const userId = req.user.userId;

    logger.try('Updating backup configuration', {
      enabled,
      frequency,
      time,
      retentionDays
    });

    // Update settings
    const settingsToUpdate = {
      backup_enabled: enabled ? 'true' : 'false',
      backup_frequency: frequency,
      backup_time: time,
      backup_retention_days: retentionDays.toString(),
      backup_email_notifications: emailNotifications ? 'true' : 'false',
      backup_email_recipients: emailRecipients
    };

    for (const [key, value] of Object.entries(settingsToUpdate)) {
      await settingsService.updateSetting({
        settingKey: key,
        settingValue: value,
        updatedBy: userId
      });
    }

    logger.success('Backup configuration updated successfully');

    return res.status(200).json(
      createResponse(true, 'Backup configuration updated successfully', settingsToUpdate)
    );

  } catch (error) {
    logger.error('Update backup config error', error);
    next(error);
  }
};

// ============================================
// EXPORTS
// ============================================
module.exports = {
  createBackup,
  getBackupHistory,
  getBackupStatistics,
  getBackupById,
  downloadBackup,
  deleteBackup,
  getBackupConfig,
  updateBackupConfig
};