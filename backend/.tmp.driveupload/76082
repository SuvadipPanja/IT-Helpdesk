// ============================================
// PASSWORD RESET CONTROLLER
// Handles self-service password reset workflow
// Developer: Suvadip Panja
// Date: January 26, 2026
// ============================================

const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const { executeQuery } = require('../config/database');
const { createResponse } = require('../utils/helpers');
const logger = require('../utils/logger');
const emailService = require('../services/email.service');
const securityService = require('../services/security.service');

/**
 * Request password reset - Send email with reset token
 * @route POST /api/v1/auth/forgot-password
 * @access Public
 */
const forgotPassword = async (req, res, next) => {
  try {
    const { email } = req.body;
    const ipAddress = req.ip;
    const userAgent = req.get('user-agent');

    logger.separator();
    logger.try('FORGOT PASSWORD REQUEST', { email, ipAddress });

    // Validate email
    if (!email) {
      logger.warn('Email not provided');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Email address is required')
      );
    }

    // Check if user exists with this email
    const userQuery = `
      SELECT 
        user_id,
        username,
        email,
        first_name,
        last_name,
        first_name + ' ' + last_name as full_name,
        is_active,
        is_locked
      FROM users
      WHERE email = @email
    `;

    const userResult = await executeQuery(userQuery, { email });

    // ⚠️ SECURITY: Don't reveal if email exists (prevent enumeration)
    // Always return success message regardless
    if (userResult.recordset.length === 0) {
      logger.warn('Email not found in database', { email });
      logger.separator();
      
      // Return success to prevent email enumeration attack
      return res.status(200).json(
        createResponse(
          true,
          'If an account with that email exists, a password reset link has been sent.'
        )
      );
    }

    const user = userResult.recordset[0];

    // Check if account is active
    if (!user.is_active) {
      logger.warn('Account is inactive', { userId: user.user_id, email });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Your account is inactive. Please contact support.')
      );
    }

    // Check if account is locked
    if (user.is_locked) {
      logger.warn('Account is locked', { userId: user.user_id, email });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Your account is locked. Please contact support.')
      );
    }

    // Generate secure random token (32 bytes = 64 hex characters)
    const resetToken = crypto.randomBytes(32).toString('hex');
    logger.info('Secure reset token generated', { userId: user.user_id });

    // Token expires in 1 hour
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000);

    // Invalidate any previous unused tokens for this user
    const invalidateQuery = `
      UPDATE password_reset_tokens
      SET used_at = GETDATE()
      WHERE user_id = @userId 
        AND used_at IS NULL
        AND expires_at > GETDATE()
    `;

    await executeQuery(invalidateQuery, { userId: user.user_id });
    logger.info('Previous tokens invalidated');

    // Store new token in database
    const insertTokenQuery = `
      INSERT INTO password_reset_tokens (
        user_id,
        token,
        expires_at,
        ip_address,
        user_agent
      )
      VALUES (
        @userId,
        @token,
        @expiresAt,
        @ipAddress,
        @userAgent
      )
    `;

    await executeQuery(insertTokenQuery, {
      userId: user.user_id,
      token: resetToken,
      expiresAt: expiresAt,
      ipAddress: ipAddress,
      userAgent: userAgent
    });

    logger.success('Reset token stored in database', { userId: user.user_id });

    // Build reset URL
    const frontendURL = process.env.FRONTEND_URL || 'http://localhost:5173';
    const resetUrl = `${frontendURL}/reset-password?token=${resetToken}`;

    logger.info('Reset URL generated', { resetUrl });

    // Send email with reset link
    try {
      await emailService.sendPasswordResetEmail(
        user.email,
        user.full_name,
        resetUrl,
        60 // 60 minutes expiry
      );

      logger.success('Password reset email sent successfully', {
        userId: user.user_id,
        email: user.email
      });
    } catch (emailError) {
      logger.error('Failed to send password reset email', emailError);

      // Delete token if email fails
      await executeQuery(
        'DELETE FROM password_reset_tokens WHERE token = @token',
        { token: resetToken }
      );

      logger.separator();
      return res.status(500).json(
        createResponse(false, 'Failed to send reset email. Please try again later.')
      );
    }

    // Log security event
    await securityService.logSecurityEvent(
      user.user_id,
      'PASSWORD_RESET_REQUESTED',
      `Password reset requested from IP: ${ipAddress}`,
      ipAddress,
      userAgent,
      true
    );

    logger.separator();

    return res.status(200).json(
      createResponse(
        true,
        'Password reset link has been sent to your email. Please check your inbox.'
      )
    );

  } catch (error) {
    logger.error('Forgot password error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Validate reset token
 * @route GET /api/v1/auth/validate-reset-token/:token
 * @access Public
 */
const validateResetToken = async (req, res, next) => {
  try {
    const { token } = req.params;

    logger.try('Validating reset token', { token: token.substring(0, 10) + '...' });

    if (!token) {
      return res.status(400).json(
        createResponse(false, 'Reset token is required', { isValid: false })
      );
    }

    // Check if token exists and is valid
    const tokenQuery = `
      SELECT 
        t.token_id,
        t.user_id,
        t.expires_at,
        t.used_at,
        u.email,
        u.first_name + ' ' + u.last_name as full_name,
        u.is_active,
        u.is_locked
      FROM password_reset_tokens t
      INNER JOIN users u ON t.user_id = u.user_id
      WHERE t.token = @token
    `;

    const tokenResult = await executeQuery(tokenQuery, { token });

    if (tokenResult.recordset.length === 0) {
      logger.warn('Token not found');
      return res.status(400).json(
        createResponse(false, 'Invalid reset token', { isValid: false })
      );
    }

    const tokenData = tokenResult.recordset[0];

    // Check if token already used
    if (tokenData.used_at) {
      logger.warn('Token already used', { tokenId: tokenData.token_id });
      return res.status(400).json(
        createResponse(false, 'This reset link has already been used', { isValid: false })
      );
    }

    // Check if token expired
    const now = new Date();
    const expiresAt = new Date(tokenData.expires_at);

    if (now > expiresAt) {
      logger.warn('Token expired', {
        tokenId: tokenData.token_id,
        expiresAt: tokenData.expires_at
      });
      return res.status(400).json(
        createResponse(false, 'Reset link has expired. Please request a new one.', { isValid: false })
      );
    }

    // Check if account is active
    if (!tokenData.is_active) {
      logger.warn('Account inactive', { userId: tokenData.user_id });
      return res.status(400).json(
        createResponse(false, 'Account is inactive', { isValid: false })
      );
    }

    // Check if account is locked
    if (tokenData.is_locked) {
      logger.warn('Account locked', { userId: tokenData.user_id });
      return res.status(400).json(
        createResponse(false, 'Account is locked', { isValid: false })
      );
    }

    logger.success('Token is valid', { userId: tokenData.user_id });

    return res.status(200).json(
      createResponse(true, 'Token is valid', {
        isValid: true,
        email: tokenData.email,
        full_name: tokenData.full_name
      })
    );

  } catch (error) {
    logger.error('Validate reset token error', error);
    next(error);
  }
};

/**
 * Reset password using token
 * @route POST /api/v1/auth/reset-password
 * @access Public
 */
const resetPassword = async (req, res, next) => {
  try {
    const { token, newPassword, confirmPassword } = req.body;
    const ipAddress = req.ip;
    const userAgent = req.get('user-agent');

    logger.separator();
    logger.try('PASSWORD RESET', { token: token?.substring(0, 10) + '...', ipAddress });

    // Validate input
    if (!token || !newPassword || !confirmPassword) {
      logger.warn('Missing required fields');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Token, new password, and password confirmation are required')
      );
    }

    // Check if passwords match
    if (newPassword !== confirmPassword) {
      logger.warn('Passwords do not match');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Passwords do not match')
      );
    }

    // Validate password strength
    if (newPassword.length < 8) {
      logger.warn('Password too short');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Password must be at least 8 characters long')
      );
    }

    // Check if token is valid
    const tokenQuery = `
      SELECT 
        t.token_id,
        t.user_id,
        t.expires_at,
        t.used_at,
        u.username,
        u.email,
        u.first_name + ' ' + u.last_name as full_name,
        u.is_active,
        u.is_locked
      FROM password_reset_tokens t
      INNER JOIN users u ON t.user_id = u.user_id
      WHERE t.token = @token
    `;

    const tokenResult = await executeQuery(tokenQuery, { token });

    if (tokenResult.recordset.length === 0) {
      logger.warn('Invalid token');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Invalid reset token')
      );
    }

    const tokenData = tokenResult.recordset[0];

    // Check if token already used
    if (tokenData.used_at) {
      logger.warn('Token already used', { tokenId: tokenData.token_id });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'This reset link has already been used')
      );
    }

    // Check if token expired
    const now = new Date();
    const expiresAt = new Date(tokenData.expires_at);

    if (now > expiresAt) {
      logger.warn('Token expired', {
        tokenId: tokenData.token_id,
        expiresAt: tokenData.expires_at
      });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Reset link has expired. Please request a new one.')
      );
    }

    // Check if account is active
    if (!tokenData.is_active) {
      logger.warn('Account inactive', { userId: tokenData.user_id });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Account is inactive. Please contact support.')
      );
    }

    // Check if account is locked
    if (tokenData.is_locked) {
      logger.warn('Account locked', { userId: tokenData.user_id });
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'Account is locked. Please contact support.')
      );
    }

    // Hash new password
    logger.try('Hashing new password');
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    logger.success('Password hashed successfully');

    // ⭐ FIXED: Update user password WITHOUT hardcoded expiry
    // We'll use securityService.updatePasswordExpiryDate() to set expiry dynamically
    const updatePasswordQuery = `
      UPDATE users
      SET 
        password_hash = @passwordHash,
        is_locked = 0,
        failed_login_attempts = 0,
        updated_at = GETDATE()
      WHERE user_id = @userId
    `;

    await executeQuery(updatePasswordQuery, {
      passwordHash: hashedPassword,
      userId: tokenData.user_id
    });

    logger.success('Password hash updated successfully', {
      userId: tokenData.user_id,
      username: tokenData.username
    });

    // ⭐ NEW: Update password_changed_at and password_expires_at using security service
    // This fetches password_expiry_days from system_settings (not hardcoded!)
    logger.try('Updating password expiry date');
    await securityService.updatePasswordExpiryDate(tokenData.user_id);
    logger.success('Password expiry date updated');

    // ⭐ NEW: Save password to history for reuse prevention
    logger.try('Saving password to history');
    await securityService.savePasswordHistory(tokenData.user_id, hashedPassword, null, 'RESET');
    logger.success('Password saved to history');

    // Mark token as used
    const markTokenUsedQuery = `
      UPDATE password_reset_tokens
      SET used_at = GETDATE()
      WHERE token_id = @tokenId
    `;

    await executeQuery(markTokenUsedQuery, {
      tokenId: tokenData.token_id
    });

    logger.success('Reset token marked as used');

    // Log security event
    await securityService.logSecurityEvent(
      tokenData.user_id,
      'PASSWORD_RESET_COMPLETED',
      `Password successfully reset via self-service from IP: ${ipAddress}`,
      ipAddress,
      userAgent,
      true
    );

    // Send confirmation email (optional)
    try {
      await emailService.sendPasswordResetConfirmationEmail(
        tokenData.email,
        tokenData.full_name
      );
      logger.success('Confirmation email sent');
    } catch (emailError) {
      logger.error('Failed to send confirmation email (non-critical)', emailError);
      // Don't fail the request if confirmation email fails
    }

    logger.separator();

    return res.status(200).json(
      createResponse(
        true,
        'Your password has been reset successfully! You can now login with your new password.',
        {
          username: tokenData.username,
          email: tokenData.email
        }
      )
    );

  } catch (error) {
    logger.error('Reset password error', error);
    logger.separator();
    next(error);
  }
};

// ============================================
// EXPORT FUNCTIONS
// ============================================
module.exports = {
  forgotPassword,
  validateResetToken,
  resetPassword,
};