// ============================================
// PASSWORD RESET CONTROLLER - COMPLETE WITH VALIDATION & HISTORY
// Handles forgot password and reset password with:
// - Password policy validation from system_settings
// - Last 3 passwords check from password_history
// - Email templates from database (no hardcoded HTML)
// - Password history tracking
// Developer: Suvadip Panja
// Company: Digitide
// Date: January 26, 2026
// ============================================

const sql = require('mssql');
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const emailService = require('../services/email.service');
const { pool } = require('../config/database');
const logger = require('../utils/logger');

// ============================================
// FORGOT PASSWORD - REQUEST RESET
// ============================================
exports.forgotPassword = async (req, res) => {
  const requestId = crypto.randomBytes(8).toString('hex');
  
  try {
    const { email } = req.body;

    // Validate email
    if (!email || !email.trim()) {
      return res.status(400).json({
        success: false,
        message: 'Email is required'
      });
    }

    logger.info(`[${requestId}] Password reset requested for email: ${email}`);

    // Get system setting for reset token expiry
    const settingsResult = await pool.request()
      .input('key', sql.VarChar, 'password_reset_token_expiry_minutes')
      .query(`
        SELECT setting_value 
        FROM system_settings 
        WHERE setting_key = @key
      `);

    const expiryMinutes = settingsResult.recordset[0]?.setting_value || '60';

    // Check if user exists
    const userResult = await pool.request()
      .input('email', sql.VarChar, email.trim().toLowerCase())
      .query(`
        SELECT user_id, username, full_name, email, is_active
        FROM users
        WHERE email = @email
      `);

    if (userResult.recordset.length === 0) {
      // Don't reveal if email exists - security best practice
      logger.warn(`[${requestId}] Password reset attempted for non-existent email: ${email}`);
      return res.json({
        success: true,
        message: 'If an account exists with this email, you will receive password reset instructions.'
      });
    }

    const user = userResult.recordset[0];

    // Check if user is active
    if (!user.is_active) {
      logger.warn(`[${requestId}] Password reset attempted for inactive user: ${email}`);
      return res.status(403).json({
        success: false,
        message: 'Your account is inactive. Please contact your administrator.'
      });
    }

    // Generate secure reset token
    const resetToken = crypto.randomBytes(32).toString('hex');
    const tokenHash = crypto.createHash('sha256').update(resetToken).digest('hex');
    const expiresAt = new Date(Date.now() + (parseInt(expiryMinutes) * 60 * 1000));

    // Delete any existing reset tokens for this user
    await pool.request()
      .input('user_id', sql.Int, user.user_id)
      .query(`DELETE FROM password_reset_tokens WHERE user_id = @user_id`);

    // Insert new reset token
    await pool.request()
      .input('user_id', sql.Int, user.user_id)
      .input('token_hash', sql.VarChar, tokenHash)
      .input('expires_at', sql.DateTime, expiresAt)
      .input('ip_address', sql.VarChar, req.ip || 'Unknown')
      .input('user_agent', sql.VarChar, req.get('user-agent') || 'Unknown')
      .query(`
        INSERT INTO password_reset_tokens (user_id, token_hash, expires_at, ip_address, user_agent)
        VALUES (@user_id, @token_hash, @expires_at, @ip_address, @user_agent)
      `);

    // Build reset URL
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    const resetUrl = `${frontendUrl}/reset-password?token=${resetToken}`;

    // Send email using template from database
    await emailService.sendPasswordResetRequest(
      user.email,
      user.full_name,
      resetUrl,
      expiryMinutes
    );

    logger.info(`[${requestId}] Password reset email sent successfully to: ${email}`);

    res.json({
      success: true,
      message: 'If an account exists with this email, you will receive password reset instructions.'
    });

  } catch (error) {
    logger.error(`[${requestId}] Forgot password error:`, error);
    res.status(500).json({
      success: false,
      message: 'Failed to process password reset request'
    });
  }
};

// ============================================
// RESET PASSWORD - VERIFY TOKEN AND UPDATE PASSWORD
// ============================================
exports.resetPassword = async (req, res) => {
  const requestId = crypto.randomBytes(8).toString('hex');
  
  try {
    const { token, newPassword } = req.body;

    // Validate input
    if (!token || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'Token and new password are required'
      });
    }

    logger.info(`[${requestId}] Password reset attempt with token`);

    // Hash the token to find in database
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

    // Find valid token
    const tokenResult = await pool.request()
      .input('token_hash', sql.VarChar, tokenHash)
      .query(`
        SELECT 
          prt.token_id,
          prt.user_id,
          prt.expires_at,
          prt.used_at,
          u.username,
          u.full_name,
          u.email,
          u.password_hash,
          u.is_active
        FROM password_reset_tokens prt
        INNER JOIN users u ON prt.user_id = u.user_id
        WHERE prt.token_hash = @token_hash
      `);

    if (tokenResult.recordset.length === 0) {
      logger.warn(`[${requestId}] Invalid reset token used`);
      return res.status(400).json({
        success: false,
        message: 'Invalid or expired reset token'
      });
    }

    const tokenData = tokenResult.recordset[0];

    // Check if user is active
    if (!tokenData.is_active) {
      logger.warn(`[${requestId}] Password reset attempted for inactive user: ${tokenData.email}`);
      return res.status(403).json({
        success: false,
        message: 'Your account is inactive. Please contact your administrator.'
      });
    }

    // Check if token has expired
    if (new Date() > new Date(tokenData.expires_at)) {
      logger.warn(`[${requestId}] Expired reset token used for user: ${tokenData.email}`);
      return res.status(400).json({
        success: false,
        message: 'Reset token has expired. Please request a new password reset.'
      });
    }

    // Check if token has already been used
    if (tokenData.used_at) {
      logger.warn(`[${requestId}] Already used reset token for user: ${tokenData.email}`);
      return res.status(400).json({
        success: false,
        message: 'This reset token has already been used. Please request a new password reset.'
      });
    }

    // ============================================
    // VALIDATE PASSWORD POLICY
    // ============================================
    const policyResult = await pool.request()
      .query(`
        SELECT setting_key, setting_value
        FROM system_settings
        WHERE setting_key IN (
          'password_min_length',
          'password_require_uppercase',
          'password_require_lowercase',
          'password_require_number',
          'password_require_special'
        )
      `);

    const policy = {};
    policyResult.recordset.forEach(row => {
      policy[row.setting_key] = row.setting_value;
    });

    const minLength = parseInt(policy.password_min_length) || 8;
    const requireUppercase = policy.password_require_uppercase === 'true';
    const requireLowercase = policy.password_require_lowercase === 'true';
    const requireNumber = policy.password_require_number === 'true';
    const requireSpecial = policy.password_require_special === 'true';

    // Validate password against policy
    const validationErrors = [];

    if (newPassword.length < minLength) {
      validationErrors.push(`Password must be at least ${minLength} characters long`);
    }

    if (requireUppercase && !/[A-Z]/.test(newPassword)) {
      validationErrors.push('Password must contain at least one uppercase letter');
    }

    if (requireLowercase && !/[a-z]/.test(newPassword)) {
      validationErrors.push('Password must contain at least one lowercase letter');
    }

    if (requireNumber && !/[0-9]/.test(newPassword)) {
      validationErrors.push('Password must contain at least one number');
    }

    if (requireSpecial && !/[!@#$%^&*(),.?":{}|<>]/.test(newPassword)) {
      validationErrors.push('Password must contain at least one special character');
    }

    if (validationErrors.length > 0) {
      logger.warn(`[${requestId}] Password policy validation failed for user: ${tokenData.email}`);
      return res.status(400).json({
        success: false,
        message: 'Password does not meet policy requirements',
        errors: validationErrors
      });
    }

    // ============================================
    // CHECK LAST 3 PASSWORDS
    // ============================================
    const historyResult = await pool.request()
      .input('user_id', sql.Int, tokenData.user_id)
      .query(`
        SELECT TOP 3 password_hash
        FROM password_history
        WHERE user_id = @user_id
        ORDER BY created_at DESC
      `);

    // Check against last 3 passwords
    for (const row of historyResult.recordset) {
      const matches = await bcrypt.compare(newPassword, row.password_hash);
      if (matches) {
        logger.warn(`[${requestId}] User attempted to reuse recent password: ${tokenData.email}`);
        return res.status(400).json({
          success: false,
          message: 'You cannot reuse any of your last 3 passwords. Please choose a different password.'
        });
      }
    }

    // Check if new password is same as current password
    const currentMatches = await bcrypt.compare(newPassword, tokenData.password_hash);
    if (currentMatches) {
      logger.warn(`[${requestId}] User attempted to use current password: ${tokenData.email}`);
      return res.status(400).json({
        success: false,
        message: 'New password cannot be the same as your current password'
      });
    }

    // ============================================
    // UPDATE PASSWORD AND ADD TO HISTORY
    // ============================================
    
    // Hash new password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // Get password expiry days from settings
    const expiryResult = await pool.request()
      .input('key', sql.VarChar, 'password_expiry_days')
      .query(`SELECT setting_value FROM system_settings WHERE setting_key = @key`);
    
    const expiryDays = parseInt(expiryResult.recordset[0]?.setting_value) || 90;
    const passwordExpiresAt = new Date();
    passwordExpiresAt.setDate(passwordExpiresAt.getDate() + expiryDays);

    // Start transaction
    const transaction = new sql.Transaction(pool);
    await transaction.begin();

    try {
      // Update user password
      await transaction.request()
        .input('user_id', sql.Int, tokenData.user_id)
        .input('password_hash', sql.VarChar, hashedPassword)
        .input('password_expires_at', sql.DateTime, passwordExpiresAt)
        .query(`
          UPDATE users 
          SET password_hash = @password_hash,
              password_expires_at = @password_expires_at,
              updated_at = GETDATE()
          WHERE user_id = @user_id
        `);

      // Add to password history
      await transaction.request()
        .input('user_id', sql.Int, tokenData.user_id)
        .input('password_hash', sql.VarChar, hashedPassword)
        .input('ip_address', sql.VarChar, req.ip || 'Unknown')
        .input('user_agent', sql.VarChar, req.get('user-agent') || 'Unknown')
        .query(`
          INSERT INTO password_history (user_id, password_hash, ip_address, user_agent)
          VALUES (@user_id, @password_hash, @ip_address, @user_agent)
        `);

      // Mark token as used
      await transaction.request()
        .input('token_id', sql.Int, tokenData.token_id)
        .query(`
          UPDATE password_reset_tokens 
          SET used_at = GETDATE()
          WHERE token_id = @token_id
        `);

      // Commit transaction
      await transaction.commit();

      logger.info(`[${requestId}] Password reset successful for user: ${tokenData.email}`);

      // Send confirmation email using template from database
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
      const loginUrl = `${frontendUrl}/login`;

      await emailService.sendPasswordResetSuccess(
        tokenData.email,
        tokenData.full_name,
        loginUrl
      );

      res.json({
        success: true,
        message: 'Password has been reset successfully. You can now login with your new password.'
      });

    } catch (transactionError) {
      await transaction.rollback();
      throw transactionError;
    }

  } catch (error) {
    logger.error(`[${requestId}] Reset password error:`, error);
    res.status(500).json({
      success: false,
      message: 'Failed to reset password. Please try again.'
    });
  }
};

// ============================================
// VERIFY RESET TOKEN - Check if token is valid
// ============================================
exports.verifyResetToken = async (req, res) => {
  const requestId = crypto.randomBytes(8).toString('hex');
  
  try {
    const { token } = req.query;

    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Token is required'
      });
    }

    // Hash the token
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

    // Find token
    const result = await pool.request()
      .input('token_hash', sql.VarChar, tokenHash)
      .query(`
        SELECT 
          prt.expires_at,
          prt.used_at,
          u.email
        FROM password_reset_tokens prt
        INNER JOIN users u ON prt.user_id = u.user_id
        WHERE prt.token_hash = @token_hash
      `);

    if (result.recordset.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid reset token'
      });
    }

    const tokenData = result.recordset[0];

    // Check if expired
    if (new Date() > new Date(tokenData.expires_at)) {
      return res.status(400).json({
        success: false,
        message: 'Reset token has expired'
      });
    }

    // Check if used
    if (tokenData.used_at) {
      return res.status(400).json({
        success: false,
        message: 'Reset token has already been used'
      });
    }

    res.json({
      success: true,
      message: 'Token is valid'
    });

  } catch (error) {
    logger.error(`[${requestId}] Verify token error:`, error);
    res.status(500).json({
      success: false,
      message: 'Failed to verify token'
    });
  }
};

// ============================================
// CLEANUP EXPIRED TOKENS - Background job
// ============================================
exports.cleanupExpiredTokens = async () => {
  try {
    const result = await pool.request().query(`
      DELETE FROM password_reset_tokens
      WHERE expires_at < GETDATE() OR used_at IS NOT NULL
    `);

    logger.info(`Cleaned up ${result.rowsAffected[0]} expired/used password reset tokens`);
  } catch (error) {
    logger.error('Error cleaning up expired tokens:', error);
  }
};