// ============================================
// TICKETS CONTROLLER
// Handles all ticket-related operations with SLA tracking
// Developed by: Suvadip Panja
// Created: November 01, 2025
// Updated: November 01, 2025 - Added SLA Service Integration
// FILE: backend/controllers/tickets.controller.js
// ============================================

const { executeQuery } = require('../config/database');
const { createResponse, getPaginationMeta } = require('../utils/helpers');
const logger = require('../utils/logger');
const sql = require('mssql');
const settingsService = require('../services/settings.service');
const emailQueueService = require('../services/emailQueue.service');
const slaService = require('../services/sla.service'); // ⭐ NEW: SLA Service

/**
 * Get all tickets with pagination and filters
 * @route GET /api/v1/tickets
 * @access Private
 */
const getTickets = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const search = req.query.search || '';
    const status_id = req.query.status_id || null;
    const priority_id = req.query.priority_id || null;
    const category_id = req.query.category_id || null;
    const assigned_to = req.query.assigned_to || null;
    const requester_id = req.query.requester_id || null;
    const department_id = req.query.department_id || null;

    const offset = (page - 1) * limit;
    
    const canViewAll = req.user.permissions?.can_view_all_tickets || false;
    const userId = req.user.user_id;

    logger.try('Fetching tickets list', {
      userId,
      canViewAll,
      page,
      limit,
      filters: { status_id, priority_id, category_id },
    });

    // Build WHERE clause based on permissions
    let whereConditions = [];
    let params = {};

    if (!canViewAll) {
      whereConditions.push('(t.requester_id = @userId OR t.assigned_to = @userId)');
      params.userId = userId;
    }

    if (search) {
      whereConditions.push(`(
        t.ticket_number LIKE '%' + @search + '%' OR 
        t.subject LIKE '%' + @search + '%' OR 
        t.description LIKE '%' + @search + '%'
      )`);
      params.search = search;
    }

    if (status_id) {
      whereConditions.push('t.status_id = @statusId');
      params.statusId = status_id;
    }

    if (priority_id) {
      whereConditions.push('t.priority_id = @priorityId');
      params.priorityId = priority_id;
    }

    if (category_id) {
      whereConditions.push('t.category_id = @categoryId');
      params.categoryId = category_id;
    }

    if (assigned_to) {
      whereConditions.push('t.assigned_to = @assignedTo');
      params.assignedTo = assigned_to;
    }

    if (requester_id) {
      whereConditions.push('t.requester_id = @requesterId');
      params.requesterId = requester_id;
    }

    if (department_id) {
      whereConditions.push('t.department_id = @departmentId');
      params.departmentId = department_id;
    }

    const whereClause = whereConditions.length > 0 
      ? 'WHERE ' + whereConditions.join(' AND ')
      : '';

    // Count total records
    const countQuery = `
      SELECT COUNT(*) as total
      FROM tickets t
      ${whereClause}
    `;

    const countResult = await executeQuery(countQuery, params);
    const totalRecords = countResult.recordset[0].total;

    // Fetch tickets
    const sortBy = req.query.sortBy || 'created_at';
    const sortOrder = req.query.sortOrder || 'DESC';

    const ticketsQuery = `
      SELECT 
        t.ticket_id,
        t.ticket_number,
        t.subject,
        t.description,
        t.created_at,
        t.updated_at,
        t.due_date,
        t.resolved_at,
        t.is_escalated,
        t.first_response_sla_met,
        t.resolution_sla_met,
        
        tc.category_id,
        tc.category_name,
        tc.category_code,
        
        tp.priority_id,
        tp.priority_name,
        tp.priority_code,
        tp.color_code as priority_color,
        
        ts.status_id,
        ts.status_name,
        ts.status_code,
        ts.status_type,
        ts.color_code as status_color,
        ts.is_final_status,
        
        u_req.user_id as requester_id,
        u_req.first_name + ' ' + u_req.last_name as requester_name,
        
        u_eng.user_id as assigned_to_id,
        u_eng.first_name + ' ' + u_eng.last_name as assigned_to_name,
        
        d.department_id,
        d.department_name
        
      FROM tickets t
      LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
      LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
      LEFT JOIN ticket_statuses ts ON t.status_id = ts.status_id
      LEFT JOIN users u_req ON t.requester_id = u_req.user_id
      LEFT JOIN users u_eng ON t.assigned_to = u_eng.user_id
      LEFT JOIN departments d ON t.department_id = d.department_id
      ${whereClause}
      ORDER BY t.${sortBy} ${sortOrder}
      OFFSET @offset ROWS
      FETCH NEXT @limit ROWS ONLY
    `;

    params.offset = offset;
    params.limit = limit;

    const ticketsResult = await executeQuery(ticketsQuery, params);

    const paginationMeta = getPaginationMeta(totalRecords, page, limit);

    logger.success('Tickets fetched successfully', {
      count: ticketsResult.recordset.length,
      page,
      totalPages: paginationMeta.totalPages,
    });

    return res.status(200).json(
      createResponse(true, 'Tickets fetched successfully', {
        tickets: ticketsResult.recordset,
        pagination: paginationMeta
      })
    );
  } catch (error) {
    logger.error('Get tickets error', error);
    next(error);
  }
};

/**
 * Get single ticket by ID
 * @route GET /api/v1/tickets/:id
 * @access Private
 */
const getTicketById = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const userId = req.user.user_id;
    
    const canViewAll = req.user.permissions?.can_view_all_tickets || false;

    logger.try('Fetching ticket details', {
      ticketId,
      userId,
      canViewAll,
    });

    const query = `
      SELECT 
        t.ticket_id,
        t.ticket_number,
        t.subject,
        t.subject as title,
        t.description,
        t.resolution_notes,
        t.created_at,
        t.updated_at,
        t.due_date,
        t.resolved_at,
        t.closed_at,
        t.is_escalated,
        t.escalated_at,
        t.escalation_reason,
        t.rating,
        t.feedback,
        t.first_response_at,
        t.first_response_sla_met,
        t.resolution_sla_met,
        
        tc.category_id,
        tc.category_name,
        tc.category_code,
        tc.sla_hours,
        
        tp.priority_id,
        tp.priority_name,
        tp.priority_code,
        tp.priority_level,
        tp.color_code as priority_color,
        tp.response_time_hours,
        tp.resolution_time_hours,
        
        ts.status_id,
        ts.status_name,
        ts.status_code,
        ts.status_type,
        ts.color_code as status_color,
        ts.is_final_status,
        
        t.requester_id,
        u_req.username as requester_username,
        u_req.email as requester_email,
        u_req.first_name + ' ' + u_req.last_name as requester_name,
        u_req.phone_number as requester_phone,
        
        t.assigned_to as assigned_to_id,
        u_eng.username as assigned_to_username,
        u_eng.email as assigned_to_email,
        u_eng.first_name + ' ' + u_eng.last_name as assigned_to_name,
        
        t.escalated_to as escalated_to_id,
        u_esc.first_name + ' ' + u_esc.last_name as escalated_to_name,
        
        d.department_id,
        d.department_name,
        d.department_code,
        
        u_creator.first_name + ' ' + u_creator.last_name as created_by_name
        
      FROM tickets t
      LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
      LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
      LEFT JOIN ticket_statuses ts ON t.status_id = ts.status_id
      LEFT JOIN users u_req ON t.requester_id = u_req.user_id
      LEFT JOIN users u_eng ON t.assigned_to = u_eng.user_id
      LEFT JOIN users u_esc ON t.escalated_to = u_esc.user_id
      LEFT JOIN departments d ON t.department_id = d.department_id
      LEFT JOIN users u_creator ON t.created_by = u_creator.user_id
      WHERE t.ticket_id = @ticketId
    `;

    const result = await executeQuery(query, { ticketId });

    if (result.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    const ticket = result.recordset[0];

    // Check permission
    if (!canViewAll && 
        ticket.requester_id !== userId && 
        ticket.assigned_to_id !== userId) {
      logger.warn('Unauthorized ticket access attempt', {
        ticketId,
        userId,
      });
      return res.status(403).json(
        createResponse(false, 'You do not have permission to view this ticket')
      );
    }

    // Get ticket attachments
    const attachmentsQuery = `
      SELECT 
        attachment_id,
        file_name,
        file_path,
        file_size_kb,
        file_type,
        uploaded_by,
        uploaded_at,
        u.first_name + ' ' + u.last_name as uploaded_by_name
      FROM ticket_attachments ta
      LEFT JOIN users u ON ta.uploaded_by = u.user_id
      WHERE ta.ticket_id = @ticketId
      ORDER BY ta.uploaded_at DESC
    `;

    const attachmentsResult = await executeQuery(attachmentsQuery, { ticketId });

    // Get ticket comments
    const commentsQuery = `
      SELECT 
        comment_id,
        comment_text,
        is_internal,
        commented_at,
        edited_at,
        u.user_id as commenter_id,
        u.first_name + ' ' + u.last_name as commenter_name,
        r.role_name as commenter_role
      FROM ticket_comments tc
      LEFT JOIN users u ON tc.commented_by = u.user_id
      LEFT JOIN user_roles r ON u.role_id = r.role_id
      WHERE tc.ticket_id = @ticketId 
        AND tc.is_deleted = 0
      ORDER BY tc.commented_at ASC
    `;

    const commentsResult = await executeQuery(commentsQuery, { ticketId });

    // Get ticket activities
    const activitiesQuery = `
      SELECT 
        activity_id,
        activity_type,
        field_name,
        old_value,
        new_value,
        description,
        performed_at,
        u.first_name + ' ' + u.last_name as performed_by_name
      FROM ticket_activities ta
      LEFT JOIN users u ON ta.performed_by = u.user_id
      WHERE ta.ticket_id = @ticketId
      ORDER BY ta.performed_at DESC
    `;

    const activitiesResult = await executeQuery(activitiesQuery, { ticketId });

    const ticketData = {
      ...ticket,
      attachments: attachmentsResult.recordset,
      comments: commentsResult.recordset,
      activities: activitiesResult.recordset,
    };

    logger.success('Ticket details fetched successfully', {
      ticketId,
      ticketNumber: ticket.ticket_number,
    });

    return res.status(200).json(
      createResponse(true, 'Ticket fetched successfully', ticketData)
    );
  } catch (error) {
    logger.error('Get ticket by ID error', error);
    next(error);
  }
};

/**
 * Create new ticket with SLA tracking
 * @route POST /api/v1/tickets
 * @access Private
 */
const createTicket = async (req, res, next) => {
  try {
    const {
      subject,
      description,
      category_id,
      priority_id,
      department_id,
    } = req.body;

    const userId = req.user.user_id;

    logger.separator('TICKET CREATION');
    logger.try('Creating new ticket', {
      subject,
      categoryId: category_id,
      priorityId: priority_id,
      createdBy: userId,
    });

    // ✅ STEP 1: FETCH ALL TICKET SETTINGS
    logger.try('Fetching ticket settings from database');
    const ticketSettings = await settingsService.getByCategory('ticket');
    const notificationSettings = await settingsService.getByCategory('notification');
    const generalSettings = await settingsService.getByCategory('general');
    
    logger.success('Ticket settings loaded', {
      prefix: ticketSettings.ticket_number_prefix || 'TKT',
      defaultPriority: ticketSettings.ticket_default_priority || 3,
      defaultCategory: ticketSettings.ticket_default_category || 9,
      autoAssignment: ticketSettings.ticket_auto_assignment === 'true' || ticketSettings.ticket_auto_assignment === true,
      assignmentMethod: ticketSettings.ticket_assignment_method || 'round_robin'
    });

    // ✅ STEP 2: USE DEFAULT PRIORITY IF NOT PROVIDED
    const finalPriorityId = priority_id || ticketSettings.ticket_default_priority || 3;
    logger.info('Priority determined', {
      provided: priority_id,
      default: ticketSettings.ticket_default_priority,
      final: finalPriorityId
    });

    // ✅ STEP 3: USE DEFAULT CATEGORY IF NOT PROVIDED
    const finalCategoryId = category_id || ticketSettings.ticket_default_category || 9;
    logger.info('Category determined', {
      provided: category_id,
      default: ticketSettings.ticket_default_category,
      final: finalCategoryId
    });

    // ✅ STEP 4: GENERATE TICKET NUMBER WITH CUSTOM PREFIX
    logger.try('Generating unique ticket number');
    
    const prefix = (ticketSettings.ticket_number_prefix || 'TKT').toUpperCase();
    const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    
    const seqQuery = `
      SELECT ISNULL(MAX(CAST(RIGHT(ticket_number, 4) AS INT)), 0) + 1 AS next_seq
      FROM tickets
      WHERE ticket_number LIKE '${prefix}-${dateStr}-%'
    `;
    
    const seqResult = await executeQuery(seqQuery);
    const sequence = seqResult.recordset[0].next_seq;
    const ticketNumber = `${prefix}-${dateStr}-${String(sequence).padStart(4, '0')}`;
    
    logger.success('Ticket number generated', { ticketNumber, prefix });

    // Get default status (Open)
    const statusQuery = `
      SELECT status_id 
      FROM ticket_statuses 
      WHERE status_code = 'OPEN' AND is_active = 1
    `;
    
    const statusResult = await executeQuery(statusQuery);
    const statusId = statusResult.recordset[0].status_id;

    // ⭐ STEP 5: CALCULATE DUE DATE USING SLA SERVICE (NEW!)
    logger.try('Calculating SLA due date');
    
    const priorityQuery = `
      SELECT resolution_time_hours 
      FROM ticket_priorities 
      WHERE priority_id = @priorityId
    `;
    
    const priorityResult = await executeQuery(priorityQuery, { priorityId: finalPriorityId });
    const slaHours = priorityResult.recordset[0].resolution_time_hours;

    // ⭐ NEW: Use SLA Service to calculate due date with business hours
    const createdAt = new Date();
    const dueDate = await slaService.calculateDueDate(createdAt, slaHours);
    
    logger.success('SLA due date calculated', {
      slaHours,
      createdAt: createdAt.toISOString(),
      dueDate: dueDate.toISOString(),
      businessHours: 'Applied'
    });

    // ✅ STEP 6: AUTO-ASSIGNMENT LOGIC
    let assignedToId = null;
    const autoAssignEnabled = ticketSettings.ticket_auto_assignment === 'true' || ticketSettings.ticket_auto_assignment === true;
    
    if (autoAssignEnabled) {
      logger.try('Auto-assignment enabled, determining engineer');
      logger.info('Assignment parameters', {
        method: ticketSettings.ticket_assignment_method,
        departmentId: department_id || null
      });
      
      const assignmentMethod = ticketSettings.ticket_assignment_method || 'round_robin';
      
      if (assignmentMethod === 'round_robin') {
        // Round Robin: Simplified version - just rotate through engineers
        const engineersQuery = `
          SELECT TOP 1 u.user_id
          FROM users u
          INNER JOIN user_roles r ON u.role_id = r.role_id
          WHERE r.role_code = 'ENGINEER'
            AND u.is_active = 1
            ${department_id ? 'AND u.department_id = @departmentId' : ''}
          ORDER BY 
            (SELECT COUNT(*) FROM tickets WHERE assigned_to = u.user_id) ASC,
            u.user_id ASC
        `;
        
        const engResult = await executeQuery(engineersQuery, { departmentId: department_id || null });
        if (engResult.recordset.length > 0) {
          assignedToId = engResult.recordset[0].user_id;
          logger.success('Engineer assigned (round robin)', { assignedToId });
        }
      } else if (assignmentMethod === 'least_loaded') {
        // Least Loaded: Assign to engineer with fewest open tickets
        const engineersQuery = `
          SELECT TOP 1 u.user_id
          FROM users u
          INNER JOIN user_roles r ON u.role_id = r.role_id
          LEFT JOIN tickets t ON u.user_id = t.assigned_to 
            AND t.status_id IN (SELECT status_id FROM ticket_statuses WHERE is_final_status = 0)
          WHERE r.role_code = 'ENGINEER'
            AND u.is_active = 1
            ${department_id ? 'AND u.department_id = @departmentId' : ''}
          GROUP BY u.user_id
          ORDER BY COUNT(t.ticket_id) ASC, u.user_id ASC
        `;
        
        const engResult = await executeQuery(engineersQuery, { departmentId: department_id || null });
        if (engResult.recordset.length > 0) {
          assignedToId = engResult.recordset[0].user_id;
          logger.success('Engineer assigned (least loaded)', { assignedToId });
        }
      }
    }

    // ⭐ STEP 7: INSERT TICKET WITH CALCULATED DUE DATE (MODIFIED!)
    logger.try('Inserting ticket into database');
    
    const insertQuery = `
      INSERT INTO tickets (
        ticket_number, subject, description,
        category_id, priority_id, status_id,
        requester_id, department_id, due_date,
        assigned_to, created_by
      )
      OUTPUT INSERTED.ticket_id
      VALUES (
        @ticketNumber, @subject, @description,
        @categoryId, @priorityId, @statusId,
        @requesterId, @departmentId, @dueDate,
        @assignedTo, @createdBy
      )
    `;

    const insertResult = await executeQuery(insertQuery, {
      ticketNumber,
      subject,
      description,
      categoryId: finalCategoryId,
      priorityId: finalPriorityId,
      statusId,
      requesterId: userId,
      departmentId: department_id || null,
      dueDate: dueDate, // ⭐ NEW: Using calculated SLA due date
      assignedTo: assignedToId,
      createdBy: userId,
    });

    const ticketId = insertResult.recordset[0].ticket_id;

    logger.success('Ticket inserted successfully', {
      ticketId,
      ticketNumber,
      dueDate: dueDate.toISOString(),
      assignedTo: assignedToId || 'Not assigned'
    });

    // Log ticket creation activity
    logger.try('Logging ticket creation activity');
    
    let activityDescription = 'Ticket created';
    if (assignedToId) {
      activityDescription += ' and auto-assigned';
    }
    
    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'CREATED', @description, @userId)
    `;
    
    await executeQuery(activityQuery, { 
      ticketId, 
      description: activityDescription,
      userId 
    });

    logger.success('Activity logged');

    // Create notification for admins/managers
    logger.try('Creating notification for administrators');
    
    const notificationQuery = `
      INSERT INTO notifications (
        user_id, notification_type, title, message, related_ticket_id
      )
      SELECT 
        u.user_id,
        'TICKET_CREATED',
        'New Ticket Created',
        'Ticket #' + @ticketNumber + ' - ' + @subject,
        @ticketId
      FROM users u
      INNER JOIN user_roles r ON u.role_id = r.role_id
      WHERE r.role_code IN ('ADMIN', 'MANAGER') 
        AND u.is_active = 1
        AND u.user_id != @userId
    `;
    
    await executeQuery(notificationQuery, {
      ticketNumber,
      subject,
      ticketId,
      userId,
    });

    logger.success('Notifications created for administrators');

    // ✅ STEP 8: SEND EMAIL NOTIFICATIONS
    try {
      const emailEnabled = notificationSettings.notify_on_ticket_created === 'true' || notificationSettings.notify_on_ticket_created === true;
      
      if (emailEnabled) {
        logger.try('Sending ticket creation email notifications');
        
        const appUrl = process.env.APP_URL || 'http://localhost:5173';
        
        // Send email to admins/managers
        const adminsQuery = `
          SELECT 
            u.user_id,
            u.email,
            u.first_name + ' ' + u.last_name as full_name
          FROM users u
          INNER JOIN user_roles r ON u.role_id = r.role_id
          WHERE r.role_code IN ('ADMIN', 'MANAGER')
            AND u.is_active = 1
            AND u.email IS NOT NULL
            AND u.user_id != @userId
        `;
        
        const admins = await executeQuery(adminsQuery, { userId });
        
        const ticketDetailsQuery = `
          SELECT 
            t.ticket_number,
            t.subject,
            t.description,
            tp.priority_name,
            tc.category_name,
            u_req.first_name + ' ' + u_req.last_name as requester_name,
            u_req.email as requester_email
          FROM tickets t
          LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
          LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
          LEFT JOIN users u_req ON t.requester_id = u_req.user_id
          WHERE t.ticket_id = @ticketId
        `;
        
        const ticketDetails = await executeQuery(ticketDetailsQuery, { ticketId });
        const ticket = ticketDetails.recordset[0];
        
        for (const admin of admins.recordset) {
          await emailQueueService.sendTemplatedEmail(
            'TICKET_CREATED',
            admin.email,
            {
              ticket_number: ticketNumber,
              subject: ticket.subject,
              description: ticket.description,
              priority: ticket.priority_name,
              category: ticket.category_name,
              requester_name: ticket.requester_name,
              requester_email: ticket.requester_email,
              created_at: new Date(createdAt).toLocaleString(),
              ticket_url: `${appUrl}/tickets/${ticketId}`,
              system_name: generalSettings.system_name || 'IT Helpdesk'
            },
            {
              recipientName: admin.full_name,
              recipientUserId: admin.user_id,
              emailType: 'TICKET_CREATED',
              relatedEntityType: 'TICKET',
              relatedEntityId: ticketId,
              priority: 2
            }
          );
        }

        logger.success(`Ticket creation emails queued for ${admins.recordset.length} admin(s)/manager(s)`);
        
        // Send email to assigned engineer if enabled
        if (assignedToId && (notificationSettings.notify_on_ticket_assigned === 'true' || notificationSettings.notify_on_ticket_assigned === true)) {
          logger.try('Sending assignment email to engineer');
          
          await new Promise(resolve => setTimeout(resolve, 500));

          const assignmentEmailQuery = `
            SELECT 
              t.ticket_number,
              t.subject,
              t.description,
              t.due_date,
              tp.priority_name,
              tc.category_name,
              u_assigned.user_id as assigned_to_id,
              u_assigned.email as assigned_to_email,
              u_assigned.first_name + ' ' + u_assigned.last_name as assigned_to_name
            FROM tickets t
            LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
            LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
            LEFT JOIN users u_assigned ON t.assigned_to = u_assigned.user_id
            WHERE t.ticket_id = @ticketId
          `;
          
          const assignmentDetails = await executeQuery(assignmentEmailQuery, { ticketId });
          
          if (assignmentDetails.recordset.length > 0) {
            const details = assignmentDetails.recordset[0];
            
            const dueDateFormatted = details.due_date ?
              new Date(details.due_date).toLocaleString('en-IN', {
                timeZone: 'Asia/Kolkata',
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
              }) : 
              'Not set';
            
            if (details.assigned_to_email) {
              await emailQueueService.sendTemplatedEmail(
                'TICKET_ASSIGNED',
                details.assigned_to_email,
                {
                  ticket_number: ticketNumber,
                  subject: details.subject,
                  description: details.description,
                  priority: details.priority_name,
                  category: details.category_name,
                  assigned_to_name: details.assigned_to_name,
                  due_date: dueDateFormatted,
                  ticket_url: `${appUrl}/tickets/${ticketId}`,
                  system_name: generalSettings.system_name || 'IT Helpdesk'
                },
                {
                  recipientName: details.assigned_to_name,
                  recipientUserId: assignedToId,
                  emailType: 'TICKET_ASSIGNED',
                  relatedEntityType: 'TICKET',
                  relatedEntityId: ticketId,
                  priority: 2
                }
              );
              
              logger.success('Assignment email queued for engineer', {
                engineer: details.assigned_to_name
              });
            }
          }
        }
        
      } else {
        logger.info('Ticket creation email notifications disabled in settings');
      }
    } catch (emailError) {
      logger.error('Failed to send ticket creation emails', emailError);
    }

    logger.separator('TICKET CREATED SUCCESSFULLY');
    logger.success('New ticket created', {
      ticketId,
      ticketNumber,
      subject,
      dueDate: dueDate.toISOString(),
      assignedTo: assignedToId || 'Unassigned'
    });
    logger.separator();

    return res.status(201).json(
      createResponse(true, 'Ticket created successfully', {
        ticket_id: ticketId,
        ticket_number: ticketNumber,
        assigned_to: assignedToId
      })
    );
  } catch (error) {
    logger.error('Create ticket error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Update ticket
 * @route PUT /api/v1/tickets/:id
 * @access Private
 */
const updateTicket = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const userId = req.user.user_id;
    
    const canAssign = req.user.permissions?.can_assign_tickets || false;
    const canClose = req.user.permissions?.can_close_tickets || false;

    logger.separator('TICKET UPDATE');
    logger.try('Updating ticket', {
      ticketId,
      updatedBy: userId,
      canAssign,
      canClose,
    });

    const {
      subject,
      description,
      category_id,
      priority_id,
      status_id,
      assigned_to,
      department_id,
      resolution_notes,
    } = req.body;

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id, requester_id, assigned_to, status_id FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    const ticket = ticketCheck.recordset[0];
    const oldStatusId = ticket.status_id;

    // Check permission
    const isOwner = ticket.requester_id === userId;
    const isAssigned = ticket.assigned_to === userId;

    if (!isOwner && !isAssigned && !canAssign) {
      logger.warn('Unauthorized update attempt', {
        ticketId,
        userId,
      });
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'You do not have permission to update this ticket')
      );
    }

    // Build update query
    const updateFields = [];
    const params = { ticketId };

    if (subject !== undefined) {
      updateFields.push('subject = @subject');
      params.subject = subject;
    }
    if (description !== undefined) {
      updateFields.push('description = @description');
      params.description = description;
    }
    if (category_id !== undefined) {
      updateFields.push('category_id = @categoryId');
      params.categoryId = category_id;
    }
    if (priority_id !== undefined) {
      updateFields.push('priority_id = @priorityId');
      params.priorityId = priority_id;
    }
    if (status_id !== undefined) {
      updateFields.push('status_id = @statusId');
      params.statusId = status_id;
    }
    if (assigned_to !== undefined && canAssign) {
      updateFields.push('assigned_to = @assignedTo');
      params.assignedTo = assigned_to || null;
    }
    if (department_id !== undefined) {
      updateFields.push('department_id = @departmentId');
      params.departmentId = department_id || null;
    }
    if (resolution_notes !== undefined) {
      updateFields.push('resolution_notes = @resolutionNotes');
      params.resolutionNotes = resolution_notes;
    }

    if (updateFields.length === 0) {
      logger.warn('No fields to update');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'No fields to update')
      );
    }

    updateFields.push('updated_at = GETDATE()');

    const updateQuery = `
      UPDATE tickets
      SET ${updateFields.join(', ')}
      WHERE ticket_id = @ticketId
    `;

    await executeQuery(updateQuery, params);

    // Log activity
    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'UPDATED', 'Ticket updated', @userId)
    `;
    
    await executeQuery(activityQuery, { ticketId, userId });

    // Send email if status changed
    if (status_id !== undefined && status_id !== oldStatusId) {
      try {
        logger.try('Sending status change email');

        const notificationSettings = await settingsService.getByCategory('notification');
        const generalSettings = await settingsService.getByCategory('general');

        if (notificationSettings.notify_on_ticket_updated !== 'false' && notificationSettings.notify_on_ticket_updated !== false) {
          const statusQuery = `
            SELECT 
              t.ticket_number,
              t.subject,
              t.requester_id,
              old_status.status_name as old_status_name,
              new_status.status_name as new_status_name,
              requester.email as requester_email,
              requester.first_name + ' ' + requester.last_name as requester_name,
              updater.first_name + ' ' + updater.last_name as updated_by_name
            FROM tickets t
            LEFT JOIN ticket_statuses old_status ON old_status.status_id = @oldStatusId
            LEFT JOIN ticket_statuses new_status ON new_status.status_id = @newStatusId
            LEFT JOIN users requester ON t.requester_id = requester.user_id
            LEFT JOIN users updater ON updater.user_id = @userId
            WHERE t.ticket_id = @ticketId
          `;

          const statusResult = await executeQuery(statusQuery, {
            ticketId,
            oldStatusId,
            newStatusId: status_id,
            userId,
          });

          if (statusResult.recordset.length > 0 && statusResult.recordset[0].requester_email) {
            const statusInfo = statusResult.recordset[0];
            const appUrl = process.env.APP_URL || 'http://localhost:5173';

            await emailQueueService.sendTemplatedEmail(
              'TICKET_STATUS_CHANGED',
              statusInfo.requester_email,
              {
                ticket_number: statusInfo.ticket_number,
                subject: statusInfo.subject,
                old_status: statusInfo.old_status_name,
                new_status: statusInfo.new_status_name,
                updated_by: statusInfo.updated_by_name,
                ticket_url: `${appUrl}/tickets/${ticketId}`,
                system_name: generalSettings.system_name || 'IT Helpdesk'
              },
              {
                recipientName: statusInfo.requester_name,
                recipientUserId: statusInfo.requester_id,
                emailType: 'TICKET_STATUS_CHANGED',
                relatedEntityType: 'TICKET',
                relatedEntityId: ticketId,
                priority: 2
              }
            );

            logger.success('Status change email queued');
          }
        }
      } catch (emailError) {
        logger.error('Failed to send status change email', emailError);
      }
    }

    logger.separator('TICKET UPDATED SUCCESSFULLY');
    logger.success('Ticket updated', {
      ticketId,
      fieldsUpdated: updateFields.length,
    });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Ticket updated successfully')
    );
  } catch (error) {
    logger.error('Update ticket error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Assign ticket to engineer
 * @route PATCH /api/v1/tickets/:id/assign
 * @access Private (Admin/Manager/Engineer)
 */
const assignTicket = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const { assigned_to } = req.body;
    const userId = req.user.user_id;

    logger.separator('TICKET ASSIGNMENT');
    logger.try('Assigning ticket', {
      ticketId,
      assignedTo: assigned_to,
      assignedBy: userId,
    });

    // Check permission
    const canAssign = req.user.permissions?.can_assign_tickets || false;
    
    if (!canAssign) {
      logger.warn('Unauthorized assignment attempt', { userId });
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'You do not have permission to assign tickets')
      );
    }

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    // Update assignment
    const updateQuery = `
      UPDATE tickets
      SET assigned_to = @assignedTo, updated_at = GETDATE()
      WHERE ticket_id = @ticketId
    `;

    await executeQuery(updateQuery, {
      ticketId,
      assignedTo: assigned_to || null,
    });

    // Log activity
    const activityDescription = assigned_to 
      ? `Ticket assigned to user ${assigned_to}`
      : 'Ticket unassigned';

    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'ASSIGNED', @description, @userId)
    `;

    await executeQuery(activityQuery, {
      ticketId,
      description: activityDescription,
      userId,
    });

    logger.separator('ASSIGNMENT SUCCESSFUL');
    logger.success('Ticket assigned successfully', {
      ticketId,
      assignedTo: assigned_to || 'Unassigned',
    });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Ticket assigned successfully')
    );
  } catch (error) {
    logger.error('Assign ticket error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Add comment to ticket
 * @route POST /api/v1/tickets/:id/comments
 * @access Private
 */
const addComment = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const { comment_text, is_internal } = req.body;
    const userId = req.user.user_id;

    logger.try('Adding comment to ticket', {
      ticketId,
      commentedBy: userId,
      isInternal: is_internal || false,
    });

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    // Insert comment
    const insertQuery = `
      INSERT INTO ticket_comments (
        ticket_id, comment_text, is_internal, commented_by
      )
      OUTPUT INSERTED.comment_id
      VALUES (@ticketId, @commentText, @isInternal, @userId)
    `;

    const result = await executeQuery(insertQuery, {
      ticketId,
      commentText: comment_text,
      isInternal: is_internal || false,
      userId,
    });

    const commentId = result.recordset[0].comment_id;

    // Log activity
    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'COMMENT_ADDED', 'Comment added', @userId)
    `;

    await executeQuery(activityQuery, { ticketId, userId });

    logger.success('Comment added successfully', {
      commentId,
      ticketId,
    });

    return res.status(201).json(
      createResponse(true, 'Comment added successfully', {
        comment_id: commentId,
      })
    );
  } catch (error) {
    logger.error('Add comment error', error);
    next(error);
  }
};

/**
 * Delete ticket
 * @route DELETE /api/v1/tickets/:id
 * @access Private (Admin only)
 */
const deleteTicket = async (req, res, next) => {
  let transaction;
  
  try {
    const ticketId = req.params.id;
    const userId = req.user.user_id;

    logger.separator('TICKET DELETION');
    logger.try('Deleting ticket', {
      ticketId,
      deletedBy: userId,
    });

    // Check permission
    const canDelete = req.user.permissions?.can_delete_tickets || false;

    if (!canDelete) {
      logger.warn('Unauthorized deletion attempt', { userId });
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'You do not have permission to delete tickets')
      );
    }

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id, ticket_number, subject FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    const ticket = ticketCheck.recordset[0];

    // Start transaction
    const pool = await sql.connect();
    transaction = new sql.Transaction(pool);
    await transaction.begin();

    logger.info('Transaction started');

    // Delete ticket attachments
    const deleteAttachmentsRequest = new sql.Request(transaction);
    deleteAttachmentsRequest.input('ticketId', sql.Int, ticketId);
    await deleteAttachmentsRequest.query('DELETE FROM ticket_attachments WHERE ticket_id = @ticketId');
    logger.success('Attachments deleted');

    // Delete ticket comments
    const deleteCommentsRequest = new sql.Request(transaction);
    deleteCommentsRequest.input('ticketId', sql.Int, ticketId);
    await deleteCommentsRequest.query('DELETE FROM ticket_comments WHERE ticket_id = @ticketId');
    logger.success('Comments deleted');

    // Delete ticket activities
    const deleteActivitiesRequest = new sql.Request(transaction);
    deleteActivitiesRequest.input('ticketId', sql.Int, ticketId);
    await deleteActivitiesRequest.query('DELETE FROM ticket_activities WHERE ticket_id = @ticketId');
    logger.success('Activities deleted');

    // Delete notifications
    const deleteNotificationsRequest = new sql.Request(transaction);
    deleteNotificationsRequest.input('ticketId', sql.Int, ticketId);
    await deleteNotificationsRequest.query(`
      DELETE FROM notifications WHERE related_ticket_id = @ticketId
    `);
    logger.success('Notifications deleted');

    // Delete ticket
    const deleteTicketRequest = new sql.Request(transaction);
    deleteTicketRequest.input('ticketId', sql.Int, ticketId);
    const deleteResult = await deleteTicketRequest.query('DELETE FROM tickets WHERE ticket_id = @ticketId');

    if (deleteResult.rowsAffected[0] === 0) {
      await transaction.rollback();
      logger.error('Failed to delete ticket');
      logger.separator();
      return res.status(500).json(
        createResponse(false, 'Failed to delete ticket')
      );
    }

    logger.success('Ticket deleted from database');

    // Commit transaction
    await transaction.commit();
    logger.success('Transaction committed successfully');

    logger.separator('TICKET DELETED SUCCESSFULLY');
    logger.success('All related data removed', {
      ticketId,
      ticketNumber: ticket.ticket_number,
    });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Ticket deleted successfully', {
        deleted_ticket_id: parseInt(ticketId),
        ticket_number: ticket.ticket_number,
        subject: ticket.subject
      })
    );

  } catch (error) {
    if (transaction) {
      try {
        await transaction.rollback();
        logger.warn('Transaction rolled back due to error');
      } catch (rollbackError) {
        logger.error('Rollback error', rollbackError);
      }
    }

    logger.error('Delete ticket error', error);
    logger.separator();
    next(error);
  }
};

// ============================================
// EXPORT ALL FUNCTIONS
// ============================================
module.exports = {
  getTickets,
  getTicketById,
  createTicket,
  updateTicket,
  assignTicket,
  addComment,
  deleteTicket,
};