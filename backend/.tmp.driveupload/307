// ============================================
// TICKETS CONTROLLER - COMPLETE WITH REQUESTER NOTIFICATION FIX
// Handles all ticket-related operations with SLA tracking
// Developed by: Suvadip Panja
// Created: November 01, 2025
// Updated: February 05, 2026 - FIXED: Added requester notification + confirmation email
// FILE: backend/controllers/tickets.controller.js
// ============================================

const { executeQuery } = require('../config/database');
const { createResponse, getPaginationMeta } = require('../utils/helpers');
const logger = require('../utils/logger');
const sql = require('mssql');
const settingsService = require('../services/settings.service');
const emailQueueService = require('../services/emailQueue.service');
const slaService = require('../services/sla.service');

/**
 * Get all tickets with pagination and filters
 * @route GET /api/v1/tickets
 * @access Private
 */
const getTickets = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const search = req.query.search || '';
    const status_id = req.query.status_id || null;
    const priority_id = req.query.priority_id || null;
    const category_id = req.query.category_id || null;
    const assigned_to = req.query.assigned_to || null;
    const requester_id = req.query.requester_id || null;
    const department_id = req.query.department_id || null;

    const offset = (page - 1) * limit;
    
    const canViewAll = req.user.permissions?.can_view_all_tickets || false;
    const userId = req.user.user_id;

    logger.try('Fetching tickets list', {
      userId,
      canViewAll,
      page,
      limit,
      filters: { status_id, priority_id, category_id },
    });

    // Build WHERE clause based on permissions
    let whereConditions = [];
    let params = {};

    if (!canViewAll) {
      whereConditions.push('(t.requester_id = @userId OR t.assigned_to = @userId)');
      params.userId = userId;
    }

    if (search) {
      whereConditions.push(`(
        t.ticket_number LIKE '%' + @search + '%' OR 
        t.subject LIKE '%' + @search + '%' OR 
        t.description LIKE '%' + @search + '%'
      )`);
      params.search = search;
    }

    if (status_id) {
      whereConditions.push('t.status_id = @statusId');
      params.statusId = status_id;
    }

    if (priority_id) {
      whereConditions.push('t.priority_id = @priorityId');
      params.priorityId = priority_id;
    }

    if (category_id) {
      whereConditions.push('t.category_id = @categoryId');
      params.categoryId = category_id;
    }

    if (assigned_to) {
      whereConditions.push('t.assigned_to = @assignedTo');
      params.assignedTo = assigned_to;
    }

    if (requester_id) {
      whereConditions.push('t.requester_id = @requesterId');
      params.requesterId = requester_id;
    }

    if (department_id) {
      whereConditions.push('t.department_id = @departmentId');
      params.departmentId = department_id;
    }

    const whereClause = whereConditions.length > 0 
      ? 'WHERE ' + whereConditions.join(' AND ')
      : '';

    // Count total records
    const countQuery = `
      SELECT COUNT(*) as total
      FROM tickets t
      ${whereClause}
    `;

    const countResult = await executeQuery(countQuery, params);
    const totalRecords = countResult.recordset[0].total;

    // Fetch tickets
    const sortBy = req.query.sortBy || 'created_at';
    const sortOrder = req.query.sortOrder || 'DESC';

    const ticketsQuery = `
      SELECT 
        t.ticket_id,
        t.ticket_number,
        t.subject,
        t.description,
        t.created_at,
        t.updated_at,
        t.due_date,
        t.resolved_at,
        t.is_escalated,
        t.first_response_sla_met,
        t.resolution_sla_met,
        
        tc.category_id,
        tc.category_name,
        tc.category_code,
        
        tp.priority_id,
        tp.priority_name,
        tp.priority_code,
        tp.color_code as priority_color,
        
        ts.status_id,
        ts.status_name,
        ts.status_code,
        ts.status_type,
        ts.color_code as status_color,
        ts.is_final_status,
        
        u_req.user_id as requester_id,
        u_req.first_name + ' ' + u_req.last_name as requester_name,
        u_req.profile_picture as requester_profile_picture,
        
        u_eng.user_id as assigned_to_id,
        u_eng.first_name + ' ' + u_eng.last_name as assigned_to_name,
        u_eng.profile_picture as assigned_profile_picture,
        
        d.department_id,
        d.department_name
        
      FROM tickets t
      LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
      LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
      LEFT JOIN ticket_statuses ts ON t.status_id = ts.status_id
      LEFT JOIN users u_req ON t.requester_id = u_req.user_id
      LEFT JOIN users u_eng ON t.assigned_to = u_eng.user_id
      LEFT JOIN departments d ON t.department_id = d.department_id
      ${whereClause}
      ORDER BY t.${sortBy} ${sortOrder}
      OFFSET @offset ROWS
      FETCH NEXT @limit ROWS ONLY
    `;

    params.offset = offset;
    params.limit = limit;

    const ticketsResult = await executeQuery(ticketsQuery, params);

    const paginationMeta = getPaginationMeta(totalRecords, page, limit);

    logger.success('Tickets fetched successfully', {
      count: ticketsResult.recordset.length,
      page,
      totalPages: paginationMeta.totalPages,
    });

    return res.status(200).json(
      createResponse(true, 'Tickets fetched successfully', {
        tickets: ticketsResult.recordset,
        pagination: paginationMeta
      })
    );
  } catch (error) {
    logger.error('Get tickets error', error);
    next(error);
  }
};

/**
 * Get single ticket by ID
 * @route GET /api/v1/tickets/:id
 * @access Private
 */
const getTicketById = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const userId = req.user.user_id;
    
    const canViewAll = req.user.permissions?.can_view_all_tickets || false;

    logger.try('Fetching ticket details', {
      ticketId,
      userId,
      canViewAll,
    });

    const query = `
      SELECT 
        t.ticket_id,
        t.ticket_number,
        t.subject,
        t.subject as title,
        t.description,
        t.resolution_notes,
        t.created_at,
        t.updated_at,
        t.due_date,
        t.resolved_at,
        t.closed_at,
        t.is_escalated,
        t.escalated_at,
        t.escalation_reason,
        t.rating,
        t.feedback,
        t.first_response_at,
        t.first_response_sla_met,
        t.resolution_sla_met,
        
        tc.category_id,
        tc.category_name,
        tc.category_code,
        tc.sla_hours,
        
        tp.priority_id,
        tp.priority_name,
        tp.priority_code,
        tp.priority_level,
        tp.color_code as priority_color,
        tp.response_time_hours,
        tp.resolution_time_hours,
        
        ts.status_id,
        ts.status_name,
        ts.status_code,
        ts.status_type,
        ts.color_code as status_color,
        ts.is_final_status,
        
        t.requester_id,
        u_req.username as requester_username,
        u_req.email as requester_email,
        u_req.first_name + ' ' + u_req.last_name as requester_name,
        u_req.phone_number as requester_phone,
        
        t.assigned_to as assigned_to_id,
        u_eng.username as assigned_to_username,
        u_eng.email as assigned_to_email,
        u_eng.first_name + ' ' + u_eng.last_name as assigned_to_name,
        
        t.escalated_to as escalated_to_id,
        u_esc.first_name + ' ' + u_esc.last_name as escalated_to_name,
        
        d.department_id,
        d.department_name,
        d.department_code,
        
        u_creator.first_name + ' ' + u_creator.last_name as created_by_name
        
      FROM tickets t
      LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
      LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
      LEFT JOIN ticket_statuses ts ON t.status_id = ts.status_id
      LEFT JOIN users u_req ON t.requester_id = u_req.user_id
      LEFT JOIN users u_eng ON t.assigned_to = u_eng.user_id
      LEFT JOIN users u_esc ON t.escalated_to = u_esc.user_id
      LEFT JOIN departments d ON t.department_id = d.department_id
      LEFT JOIN users u_creator ON t.created_by = u_creator.user_id
      WHERE t.ticket_id = @ticketId
    `;

    const result = await executeQuery(query, { ticketId });

    if (result.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    const ticket = result.recordset[0];

    // Check if user has permission to view this ticket
    const hasPermission = canViewAll || 
                         ticket.requester_id === userId || 
                         ticket.assigned_to_id === userId;

    if (!hasPermission) {
      logger.warn('Unauthorized access attempt', {
        ticketId,
        userId,
        requester: ticket.requester_id,
        assigned: ticket.assigned_to_id,
      });
      return res.status(403).json(
        createResponse(false, 'You do not have permission to view this ticket')
      );
    }

    // Get ticket attachments
    const attachmentsQuery = `
      SELECT 
        attachment_id,
        file_name,
        file_path,
        file_size_kb,
        file_type,
        uploaded_at,
        uploaded_by,
        u.first_name + ' ' + u.last_name as uploaded_by_name
      FROM ticket_attachments ta
      LEFT JOIN users u ON ta.uploaded_by = u.user_id
      WHERE ta.ticket_id = @ticketId
      ORDER BY ta.uploaded_at DESC
    `;

    const attachmentsResult = await executeQuery(attachmentsQuery, { ticketId });

    // Get ticket comments
    const commentsQuery = `
      SELECT 
        comment_id,
        comment_text,
        is_internal,
        commented_at,
        edited_at,
        u.user_id as commenter_id,
        u.first_name + ' ' + u.last_name as commenter_name,
        r.role_name as commenter_role
      FROM ticket_comments tc
      LEFT JOIN users u ON tc.commented_by = u.user_id
      LEFT JOIN user_roles r ON u.role_id = r.role_id
      WHERE tc.ticket_id = @ticketId 
        AND tc.is_deleted = 0
      ORDER BY tc.commented_at ASC
    `;

    const commentsResult = await executeQuery(commentsQuery, { ticketId });

    // Get ticket activities
    const activitiesQuery = `
      SELECT 
        activity_id,
        activity_type,
        field_name,
        old_value,
        new_value,
        description,
        performed_at,
        u.first_name + ' ' + u.last_name as performed_by_name
      FROM ticket_activities ta
      LEFT JOIN users u ON ta.performed_by = u.user_id
      WHERE ta.ticket_id = @ticketId
      ORDER BY ta.performed_at DESC
    `;

    const activitiesResult = await executeQuery(activitiesQuery, { ticketId });

    const ticketData = {
      ...ticket,
      attachments: attachmentsResult.recordset,
      comments: commentsResult.recordset,
      activities: activitiesResult.recordset,
    };

    logger.success('Ticket details fetched successfully', {
      ticketId,
      ticketNumber: ticket.ticket_number,
    });

    return res.status(200).json(
      createResponse(true, 'Ticket fetched successfully', ticketData)
    );
  } catch (error) {
    logger.error('Get ticket by ID error', error);
    next(error);
  }
};

/**
 * Create new ticket with FIXED SLA tracking + REQUESTER NOTIFICATION
 * @route POST /api/v1/tickets
 * @access Private
 * â­ FIXED: Now sends notification and confirmation email to ticket creator
 */
const createTicket = async (req, res, next) => {
  try {
    const {
      subject,
      description,
      category_id,
      priority_id,
      department_id,
    } = req.body;

    const userId = req.user.user_id;

    logger.separator('TICKET CREATION - WITH REQUESTER NOTIFICATION');
    logger.try('Creating new ticket', {
      subject,
      categoryId: category_id,
      priorityId: priority_id,
      createdBy: userId,
    });

    // ============================================
    // â­ STEP 1: FETCH ALL SETTINGS (INCLUDING SLA)
    // ============================================
    logger.try('Fetching all settings from database');
    const ticketSettings = await settingsService.getByCategory('ticket');
    const slaSettings = await settingsService.getByCategory('sla');
    const notificationSettings = await settingsService.getByCategory('notification');
    const generalSettings = await settingsService.getByCategory('general');
    
    logger.success('All settings loaded', {
      prefix: ticketSettings.ticket_number_prefix || 'TKT',
      defaultPriority: ticketSettings.ticket_default_priority || 3,
      defaultCategory: ticketSettings.ticket_default_category || 9,
      autoAssignment: ticketSettings.ticket_auto_assignment === 'true' || ticketSettings.ticket_auto_assignment === true,
      assignmentMethod: ticketSettings.ticket_assignment_method || 'round_robin',
      slaEnabled: slaSettings.sla_enabled
    });

    // âœ… STEP 2: USE DEFAULT PRIORITY IF NOT PROVIDED
    const finalPriorityId = priority_id || ticketSettings.ticket_default_priority || 3;
    logger.info('Priority determined', {
      provided: priority_id,
      default: ticketSettings.ticket_default_priority,
      final: finalPriorityId
    });

    // âœ… STEP 3: USE DEFAULT CATEGORY IF NOT PROVIDED
    const finalCategoryId = category_id || ticketSettings.ticket_default_category || 9;
    logger.info('Category determined', {
      provided: category_id,
      default: ticketSettings.ticket_default_category,
      final: finalCategoryId
    });

    // âœ… STEP 4: GENERATE TICKET NUMBER WITH CUSTOM PREFIX
    logger.try('Generating unique ticket number');
    
    const prefix = (ticketSettings.ticket_number_prefix || 'TKT').toUpperCase();
    const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    
    const seqQuery = `
      SELECT ISNULL(MAX(CAST(RIGHT(ticket_number, 4) AS INT)), 0) + 1 AS next_seq
      FROM tickets
      WHERE ticket_number LIKE '${prefix}-${dateStr}-%'
    `;
    
    const seqResult = await executeQuery(seqQuery);
    const sequence = seqResult.recordset[0].next_seq;
    const ticketNumber = `${prefix}-${dateStr}-${String(sequence).padStart(4, '0')}`;
    
    logger.success('Ticket number generated', { ticketNumber, prefix });

    // Get default status (Open)
    const statusQuery = `
      SELECT status_id 
      FROM ticket_statuses 
      WHERE status_code = 'OPEN' AND is_active = 1
    `;
    
    const statusResult = await executeQuery(statusQuery);
    const statusId = statusResult.recordset[0].status_id;

    // ============================================
    // â­â­â­ STEP 5: CRITICAL FIX - CHECK SLA ENABLED/DISABLED â­â­â­
    // ============================================
    logger.try('Calculating due date based on SLA configuration');
    
    // Get priority resolution time
    const priorityQuery = `
      SELECT resolution_time_hours 
      FROM ticket_priorities 
      WHERE priority_id = @priorityId
    `;
    
    const priorityResult = await executeQuery(priorityQuery, { priorityId: finalPriorityId });
    const slaHours = priorityResult.recordset[0].resolution_time_hours;

    // â­ CRITICAL: Check if SLA tracking is enabled
    const slaEnabled = slaSettings.sla_enabled === 'true' || slaSettings.sla_enabled === true;
    
    logger.info('ðŸ” SLA Configuration Check', {
      slaEnabled: slaEnabled,
      rawValue: slaSettings.sla_enabled,
      valueType: typeof slaSettings.sla_enabled,
      resolutionHours: slaHours
    });

    const createdAt = new Date();
    let dueDate;

    if (slaEnabled) {
      // ============================================
      // PATH A: SLA ENABLED - Use Business Hours Calculation
      // ============================================
      logger.success('âœ… SLA TRACKING IS ENABLED');
      logger.info('ðŸ“Š Using BUSINESS HOURS calculation for due date');
      logger.info('ðŸ“… SLA Parameters', {
        resolutionHours: slaHours,
        businessHoursStart: slaSettings.sla_business_hours_start,
        businessHoursEnd: slaSettings.sla_business_hours_end,
        workingDays: slaSettings.sla_working_days
      });

      // Use SLA Service to calculate due date with business hours
      dueDate = await slaService.calculateDueDate(createdAt, slaHours);
      
      logger.success('âœ… Due date calculated using BUSINESS HOURS', {
        createdAt: createdAt.toISOString(),
        slaHours: slaHours,
        dueDate: dueDate ? dueDate.toISOString() : 'NULL (SLA disabled)',
        dueDateIST: dueDate ? dueDate.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }) : 'N/A',
        calculationType: 'SLA Business Hours'
      });

    } else {
      // ============================================
      // PATH B: SLA DISABLED - NO DUE DATE SET
      // ============================================
      logger.warn('âš ï¸ SLA TRACKING IS DISABLED');
      logger.info('âŒ NO DUE DATE will be set (due_date = NULL)');
      logger.info('ðŸ’¡ Tickets created without SLA tracking will show "No SLA" badge');
      
      // â­ CRITICAL FIX: Set due date to NULL when SLA is disabled
      dueDate = null;
      
      logger.success('âœ… Due date set to NULL (SLA disabled)', {
        createdAt: createdAt.toISOString(),
        dueDate: 'NULL',
        slaTracking: 'Disabled',
        note: 'No SLA tracking for this ticket'
      });
    }

    // âœ… STEP 6: AUTO-ASSIGNMENT LOGIC
    let assignedToId = null;
    const autoAssignEnabled = ticketSettings.ticket_auto_assignment === 'true' || ticketSettings.ticket_auto_assignment === true;
    
    if (autoAssignEnabled) {
      logger.try('Auto-assignment enabled, determining engineer');
      logger.info('Assignment parameters', {
        method: ticketSettings.ticket_assignment_method,
        departmentId: department_id || null
      });
      
      const assignmentMethod = ticketSettings.ticket_assignment_method || 'round_robin';
      
      if (assignmentMethod === 'round_robin') {
        // Round Robin: Simplified version - just rotate through engineers
        const engineersQuery = `
          SELECT TOP 1 u.user_id
          FROM users u
          INNER JOIN user_roles r ON u.role_id = r.role_id
          WHERE r.role_code = 'ENGINEER'
            AND u.is_active = 1
            ${department_id ? 'AND u.department_id = @departmentId' : ''}
          ORDER BY 
            (SELECT COUNT(*) FROM tickets WHERE assigned_to = u.user_id) ASC,
            u.user_id ASC
        `;
        
        const engResult = await executeQuery(engineersQuery, { departmentId: department_id || null });
        if (engResult.recordset.length > 0) {
          assignedToId = engResult.recordset[0].user_id;
          logger.success('Engineer assigned (round robin)', { assignedToId });
        }
      } else if (assignmentMethod === 'least_loaded') {
        // Least Loaded: Assign to engineer with fewest open tickets
        const engineersQuery = `
          SELECT TOP 1 u.user_id
          FROM users u
          INNER JOIN user_roles r ON u.role_id = r.role_id
          LEFT JOIN tickets t ON u.user_id = t.assigned_to 
            AND t.status_id IN (SELECT status_id FROM ticket_statuses WHERE is_final_status = 0)
          WHERE r.role_code = 'ENGINEER'
            AND u.is_active = 1
            ${department_id ? 'AND u.department_id = @departmentId' : ''}
          GROUP BY u.user_id
          ORDER BY COUNT(t.ticket_id) ASC, u.user_id ASC
        `;
        
        const engResult = await executeQuery(engineersQuery, { departmentId: department_id || null });
        if (engResult.recordset.length > 0) {
          assignedToId = engResult.recordset[0].user_id;
          logger.success('Engineer assigned (least loaded)', { assignedToId });
        }
      }
    }

    // â­ STEP 7: INSERT TICKET WITH CALCULATED DUE DATE
    logger.try('Inserting ticket into database');
    
    const insertQuery = `
      INSERT INTO tickets (
        ticket_number, subject, description,
        category_id, priority_id, status_id,
        requester_id, department_id, due_date,
        assigned_to, created_by
      )
      OUTPUT INSERTED.ticket_id
      VALUES (
        @ticketNumber, @subject, @description,
        @categoryId, @priorityId, @statusId,
        @requesterId, @departmentId, @dueDate,
        @assignedTo, @createdBy
      )
    `;

    const insertResult = await executeQuery(insertQuery, {
      ticketNumber,
      subject,
      description,
      categoryId: finalCategoryId,
      priorityId: finalPriorityId,
      statusId,
      requesterId: userId,
      departmentId: department_id || null,
      dueDate: dueDate,
      assignedTo: assignedToId,
      createdBy: userId,
    });

    const ticketId = insertResult.recordset[0].ticket_id;

    logger.success('Ticket inserted successfully', {
      ticketId,
      ticketNumber,
      dueDate: dueDate ? dueDate.toISOString() : 'NULL (SLA disabled)',
      slaEnabled: slaEnabled,
      assignedTo: assignedToId || 'Not assigned'
    });

    // Log ticket creation activity
    logger.try('Logging ticket creation activity');
    
    let activityDescription = 'Ticket created';
    if (assignedToId) {
      activityDescription += ' and auto-assigned';
    }
    if (slaEnabled) {
      activityDescription += ' (SLA tracking enabled)';
    } else {
      activityDescription += ' (SLA tracking disabled)';
    }
    
    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'CREATED', @description, @userId)
    `;
    
    await executeQuery(activityQuery, { 
      ticketId, 
      description: activityDescription,
      userId 
    });

    logger.success('Activity logged');

    // Create notification for admins/managers
    logger.try('Creating notification for administrators');
    
    const notificationQuery = `
      INSERT INTO notifications (
        user_id, notification_type, title, message, related_ticket_id
      )
      SELECT 
        u.user_id,
        'TICKET_CREATED',
        'New Ticket Created',
        'Ticket #' + @ticketNumber + ' - ' + @subject,
        @ticketId
      FROM users u
      INNER JOIN user_roles r ON u.role_id = r.role_id
      WHERE r.role_code IN ('ADMIN', 'MANAGER') 
        AND u.is_active = 1
        AND u.user_id != @userId
    `;
    
    await executeQuery(notificationQuery, {
      ticketNumber,
      subject,
      ticketId,
      userId,
    });

    logger.success('Notifications created for administrators');

    // ============================================
    // â­ NEW FIX: CREATE NOTIFICATION FOR TICKET CREATOR (REQUESTER)
    // This shows a bell notification to the user who created the ticket
    // ============================================
    logger.try('Creating confirmation notification for ticket creator');

    const requesterNotificationQuery = `
      INSERT INTO notifications (
        user_id, notification_type, title, message, related_ticket_id
      )
      VALUES (
        @userId,
        'TICKET_CONFIRMATION',
        'Ticket Created Successfully',
        'Your ticket #' + @ticketNumber + ' - ' + @subject + ' has been created successfully. Our support team has been notified.',
        @ticketId
      )
    `;

    await executeQuery(requesterNotificationQuery, {
      userId,
      ticketNumber,
      subject,
      ticketId,
    });

    logger.success('Confirmation notification created for ticket creator', { userId, ticketNumber });

    // âœ… STEP 8: SEND EMAIL NOTIFICATIONS
    try {
      const emailEnabled = notificationSettings.notify_on_ticket_created === 'true' || notificationSettings.notify_on_ticket_created === true;
      
      if (emailEnabled) {
        logger.try('Sending ticket creation email notifications');
        
        const appUrl = process.env.APP_URL || 'http://localhost:5173';
        
        // Send email to admins/managers
        const adminsQuery = `
          SELECT 
            u.user_id,
            u.email,
            u.first_name + ' ' + u.last_name as full_name
          FROM users u
          INNER JOIN user_roles r ON u.role_id = r.role_id
          WHERE r.role_code IN ('ADMIN', 'MANAGER')
            AND u.is_active = 1
            AND u.email IS NOT NULL
            AND u.user_id != @userId
        `;
        
        const admins = await executeQuery(adminsQuery, { userId });
        
        const ticketDetailsQuery = `
          SELECT 
            t.ticket_number,
            t.subject,
            t.description,
            t.created_at,
            t.due_date,
            tp.priority_name,
            tc.category_name,
            u_req.first_name + ' ' + u_req.last_name as requester_name,
            u_req.email as requester_email
          FROM tickets t
          LEFT JOIN ticket_priorities tp ON t.priority_id = tp.priority_id
          LEFT JOIN ticket_categories tc ON t.category_id = tc.category_id
          LEFT JOIN users u_req ON t.requester_id = u_req.user_id
          WHERE t.ticket_id = @ticketId
        `;
        
        const details = (await executeQuery(ticketDetailsQuery, { ticketId })).recordset[0];
        
        // Format dates in IST
        const createdAtFormatted = new Date(details.created_at).toLocaleString('en-IN', {
          timeZone: 'Asia/Kolkata',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        });
        
        const dueDateFormatted = details.due_date ? new Date(details.due_date).toLocaleString('en-IN', {
          timeZone: 'Asia/Kolkata',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        }) : 'Not set (SLA disabled)';
        
        // Queue emails for all admins/managers
        for (const admin of admins.recordset) {
          await emailQueueService.sendTemplatedEmail(
            'TICKET_CREATED',
            admin.email,
            {
              ticket_number: ticketNumber,
              subject: details.subject,
              description: details.description,
              priority: details.priority_name,
              category: details.category_name,
              requester_name: details.requester_name,
              requester_email: details.requester_email,
              created_at: createdAtFormatted,
              due_date: dueDateFormatted,
              ticket_url: `${appUrl}/tickets/${ticketId}`,
              system_name: generalSettings.system_name || 'IT Helpdesk',
              sla_enabled: slaEnabled ? 'Yes' : 'No'
            },
            {
              recipientName: admin.full_name,
              recipientUserId: admin.user_id,
              emailType: 'TICKET_CREATED',
              relatedEntityType: 'TICKET',
              relatedEntityId: ticketId,
              priority: 2
            }
          );
        }
        
        logger.success('Email notifications queued for admins/managers', {
          count: admins.recordset.length
        });

        // ============================================
        // â­ NEW FIX: SEND CONFIRMATION EMAIL TO TICKET CREATOR (REQUESTER)
        // Uses TICKET_CONFIRMATION template (template_id 15)
        // This tells the user "Your ticket has been created successfully"
        // ============================================
        logger.try('Sending confirmation email to ticket creator (requester)');

        if (details.requester_email) {
          await emailQueueService.sendTemplatedEmail(
            'TICKET_CONFIRMATION',
            details.requester_email,
            {
              ticket_number: ticketNumber,
              subject: details.subject,
              description: details.description,
              priority: details.priority_name,
              category: details.category_name,
              requester_name: details.requester_name,
              created_at: createdAtFormatted,
              due_date: dueDateFormatted,
              ticket_url: `${appUrl}/tickets/${ticketId}`,
              system_name: generalSettings.system_name || 'IT Helpdesk'
            },
            {
              recipientName: details.requester_name,
              recipientUserId: userId,
              emailType: 'TICKET_CONFIRMATION',
              relatedEntityType: 'TICKET',
              relatedEntityId: ticketId,
              priority: 2
            }
          );

          logger.success('âœ… Confirmation email queued for ticket creator', {
            email: details.requester_email,
            ticketNumber: ticketNumber,
            template: 'TICKET_CONFIRMATION'
          });
        } else {
          logger.warn('Requester email not found, skipping confirmation email', { userId });
        }

      } else {
        logger.info('Email notifications disabled in settings');
      }
    } catch (emailError) {
      logger.error('Failed to send email notifications', emailError);
      // Don't fail ticket creation if email fails
    }

    logger.separator('TICKET CREATED SUCCESSFULLY');
    logger.success('New ticket created', {
      ticketId,
      ticketNumber,
      subject,
      dueDate: dueDate ? dueDate.toISOString() : 'NULL (SLA disabled)',
      slaEnabled: slaEnabled,
      assignedTo: assignedToId || 'Unassigned'
    });
    logger.separator();

    return res.status(201).json(
      createResponse(true, 'Ticket created successfully', {
        ticket_id: ticketId,
        ticket_number: ticketNumber,
        due_date: dueDate,
        sla_enabled: slaEnabled
      })
    );
  } catch (error) {
    logger.error('Create ticket error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Update ticket
 * @route PUT /api/v1/tickets/:id
 * @access Private
 */
const updateTicket = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const userId = req.user.user_id;
    
    const canAssign = req.user.permissions?.can_assign_tickets || false;
    const canClose = req.user.permissions?.can_close_tickets || false;

    logger.separator('TICKET UPDATE');
    logger.try('Updating ticket', {
      ticketId,
      updatedBy: userId,
      canAssign,
      canClose,
    });

    const {
      subject,
      description,
      category_id,
      priority_id,
      status_id,
      assigned_to,
      department_id,
      resolution_notes,
    } = req.body;

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id, requester_id, assigned_to, status_id FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    const ticket = ticketCheck.recordset[0];
    const oldStatusId = ticket.status_id;

    // Check permission
    const isOwner = ticket.requester_id === userId;
    const isAssigned = ticket.assigned_to === userId;

    if (!isOwner && !isAssigned && !canAssign) {
      logger.warn('Unauthorized update attempt', {
        ticketId,
        userId,
      });
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'You do not have permission to update this ticket')
      );
    }

    // Build update query
    const updateFields = [];
    const params = { ticketId };

    if (subject !== undefined) {
      updateFields.push('subject = @subject');
      params.subject = subject;
    }
    if (description !== undefined) {
      updateFields.push('description = @description');
      params.description = description;
    }
    if (category_id !== undefined) {
      updateFields.push('category_id = @categoryId');
      params.categoryId = category_id;
    }
    if (priority_id !== undefined) {
      updateFields.push('priority_id = @priorityId');
      params.priorityId = priority_id;
    }
    if (status_id !== undefined) {
      updateFields.push('status_id = @statusId');
      params.statusId = status_id;

      // Check if status is final (resolved/closed)
      const statusCheckQuery = `
        SELECT is_final_status 
        FROM ticket_statuses 
        WHERE status_id = @statusId
      `;
      const statusResult = await executeQuery(statusCheckQuery, { statusId: status_id });
      
      if (statusResult.recordset[0].is_final_status) {
        updateFields.push('resolved_at = GETDATE()');
      }
    }
    if (assigned_to !== undefined && canAssign) {
      updateFields.push('assigned_to = @assignedTo');
      params.assignedTo = assigned_to || null;
    }
    if (department_id !== undefined) {
      updateFields.push('department_id = @departmentId');
      params.departmentId = department_id || null;
    }
    if (resolution_notes !== undefined) {
      updateFields.push('resolution_notes = @resolutionNotes');
      params.resolutionNotes = resolution_notes;
    }

    if (updateFields.length === 0) {
      logger.warn('No fields to update');
      logger.separator();
      return res.status(400).json(
        createResponse(false, 'No fields to update')
      );
    }

    updateFields.push('updated_at = GETDATE()');

    const updateQuery = `
      UPDATE tickets
      SET ${updateFields.join(', ')}
      WHERE ticket_id = @ticketId
    `;

    await executeQuery(updateQuery, params);

    // Log activity for each changed field
    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'UPDATED', 'Ticket updated', @userId)
    `;

    await executeQuery(activityQuery, { ticketId, userId });

    // Send email notification if status changed
    if (status_id !== undefined && status_id !== oldStatusId) {
      try {
        logger.try('Sending status change email notification');

        const notificationSettings = await settingsService.getByCategory('notification');
        const generalSettings = await settingsService.getByCategory('general');

        const emailEnabled = notificationSettings.notify_on_ticket_updated === 'true' || notificationSettings.notify_on_ticket_updated === true;

        if (emailEnabled) {
          const ticketDetailsQuery = `
            SELECT 
              t.ticket_number,
              t.subject,
              ts.status_name,
              u_req.email as requester_email,
              u_req.first_name + ' ' + u_req.last_name as requester_name
            FROM tickets t
            LEFT JOIN ticket_statuses ts ON t.status_id = ts.status_id
            LEFT JOIN users u_req ON t.requester_id = u_req.user_id
            WHERE t.ticket_id = @ticketId
          `;
          
          const details = (await executeQuery(ticketDetailsQuery, { ticketId })).recordset[0];
          
          if (details.requester_email) {
            await emailQueueService.sendTemplatedEmail(
              'TICKET_STATUS_CHANGED',
              details.requester_email,
              {
                ticket_number: details.ticket_number,
                subject: details.subject,
                new_status: details.status_name,
                old_status: 'Previous Status',
                user_name: details.requester_name,
                updated_by_name: req.user.first_name + ' ' + req.user.last_name,
                ticket_url: `${process.env.APP_URL || 'http://localhost:5173'}/tickets/${ticketId}`,
                system_name: generalSettings.system_name || 'IT Helpdesk'
              },
              {
                recipientName: details.requester_name,
                emailType: 'TICKET_STATUS_CHANGED',
                relatedEntityType: 'TICKET',
                relatedEntityId: ticketId,
                priority: 3
              }
            );

            logger.success('Status change email queued');
          }
        }
      } catch (emailError) {
        logger.error('Failed to send status change email', emailError);
      }
    }

    logger.separator('TICKET UPDATED SUCCESSFULLY');
    logger.success('Ticket updated', {
      ticketId,
      fieldsUpdated: updateFields.length,
    });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Ticket updated successfully')
    );
  } catch (error) {
    logger.error('Update ticket error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Assign ticket to engineer
 * @route PATCH /api/v1/tickets/:id/assign
 * @access Private (Admin/Manager/Engineer)
 */
const assignTicket = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const { assigned_to } = req.body;
    const userId = req.user.user_id;

    logger.separator('TICKET ASSIGNMENT');
    logger.try('Assigning ticket', {
      ticketId,
      assignedTo: assigned_to,
      assignedBy: userId,
    });

    // Check permission
    const canAssign = req.user.permissions?.can_assign_tickets || false;
    
    if (!canAssign) {
      logger.warn('Unauthorized assignment attempt', { userId });
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'You do not have permission to assign tickets')
      );
    }

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id, ticket_number FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    // Update assignment
    const updateQuery = `
      UPDATE tickets
      SET assigned_to = @assignedTo, updated_at = GETDATE()
      WHERE ticket_id = @ticketId
    `;

    await executeQuery(updateQuery, {
      ticketId,
      assignedTo: assigned_to || null,
    });

    // Log activity
    const activityDescription = assigned_to 
      ? `Ticket assigned to engineer (ID: ${assigned_to})`
      : 'Ticket unassigned';

    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'ASSIGNED', @description, @userId)
    `;

    await executeQuery(activityQuery, {
      ticketId,
      description: activityDescription,
      userId,
    });

    // Send notification to assigned engineer
    if (assigned_to) {
      try {
        const notificationSettings = await settingsService.getByCategory('notification');
        const emailEnabled = notificationSettings.notify_on_ticket_assigned === 'true' || notificationSettings.notify_on_ticket_assigned === true;

        if (emailEnabled) {
          const ticketDetails = ticketCheck.recordset[0];
          const generalSettings = await settingsService.getByCategory('general');

          // Get engineer details
          const engineerQuery = `
            SELECT email, first_name + ' ' + last_name as full_name
            FROM users WHERE user_id = @assignedTo
          `;
          const engineerResult = await executeQuery(engineerQuery, { assignedTo: assigned_to });

          if (engineerResult.recordset.length > 0) {
            const engineer = engineerResult.recordset[0];

            await emailQueueService.sendTemplatedEmail(
              'TICKET_ASSIGNED',
              engineer.email,
              {
                ticket_number: ticketDetails.ticket_number,
                subject: ticketDetails.subject || 'Ticket Assigned',
                priority: 'Normal',
                due_date: 'As per SLA',
                assigned_to_name: engineer.full_name,
                ticket_url: `${process.env.APP_URL || 'http://localhost:5173'}/tickets/${ticketId}`,
                system_name: generalSettings.system_name || 'IT Helpdesk'
              },
              {
                recipientName: engineer.full_name,
                recipientUserId: assigned_to,
                emailType: 'TICKET_ASSIGNED',
                relatedEntityType: 'TICKET',
                relatedEntityId: ticketId,
                priority: 2
              }
            );

            logger.success('Assignment notification email queued', { email: engineer.email });
          }
        }
      } catch (notifyError) {
        logger.error('Failed to send assignment notification', notifyError);
      }
    }

    logger.separator('TICKET ASSIGNED SUCCESSFULLY');
    logger.success('Ticket assignment updated', {
      ticketId,
      assignedTo: assigned_to || 'Unassigned',
    });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Ticket assigned successfully')
    );
  } catch (error) {
    logger.error('Assign ticket error', error);
    logger.separator();
    next(error);
  }
};

/**
 * Add comment to ticket
 * @route POST /api/v1/tickets/:id/comments
 * @access Private
 */
const addComment = async (req, res, next) => {
  try {
    const ticketId = req.params.id;
    const { comment_text, is_internal } = req.body;
    const userId = req.user.user_id;

    logger.try('Adding comment to ticket', {
      ticketId,
      isInternal: is_internal || false,
      userId,
    });

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    // Insert comment
    const insertQuery = `
      INSERT INTO ticket_comments (
        ticket_id, comment_text, is_internal, commented_by
      )
      OUTPUT INSERTED.comment_id
      VALUES (@ticketId, @commentText, @isInternal, @userId)
    `;

    const result = await executeQuery(insertQuery, {
      ticketId,
      commentText: comment_text,
      isInternal: is_internal || false,
      userId,
    });

    const commentId = result.recordset[0].comment_id;

    // Log activity
    const activityQuery = `
      INSERT INTO ticket_activities (
        ticket_id, activity_type, description, performed_by
      )
      VALUES (@ticketId, 'COMMENT_ADDED', 'Comment added', @userId)
    `;

    await executeQuery(activityQuery, { ticketId, userId });

    logger.success('Comment added successfully', {
      commentId,
      ticketId,
    });

    return res.status(201).json(
      createResponse(true, 'Comment added successfully', {
        comment_id: commentId,
      })
    );
  } catch (error) {
    logger.error('Add comment error', error);
    next(error);
  }
};

/**
 * Delete ticket
 * @route DELETE /api/v1/tickets/:id
 * @access Private (Admin only)
 */
const deleteTicket = async (req, res, next) => {
  let transaction;
  
  try {
    const ticketId = req.params.id;
    const userId = req.user.user_id;

    logger.separator('TICKET DELETION');
    logger.try('Deleting ticket', {
      ticketId,
      deletedBy: userId,
    });

    // Check permission
    const canDelete = req.user.permissions?.can_delete_tickets || false;

    if (!canDelete) {
      logger.warn('Unauthorized deletion attempt', { userId });
      logger.separator();
      return res.status(403).json(
        createResponse(false, 'You do not have permission to delete tickets')
      );
    }

    // Check if ticket exists
    const ticketCheck = await executeQuery(
      'SELECT ticket_id, ticket_number, subject FROM tickets WHERE ticket_id = @ticketId',
      { ticketId }
    );

    if (ticketCheck.recordset.length === 0) {
      logger.warn('Ticket not found', { ticketId });
      logger.separator();
      return res.status(404).json(
        createResponse(false, 'Ticket not found')
      );
    }

    const ticket = ticketCheck.recordset[0];

    // Start transaction for cascade delete
    const pool = await require('../config/database').getPool();
    transaction = new sql.Transaction(pool);
    await transaction.begin();

    logger.try('Starting transaction for cascade delete');

    // Delete attachments
    const deleteAttachmentsRequest = new sql.Request(transaction);
    deleteAttachmentsRequest.input('ticketId', sql.Int, ticketId);
    await deleteAttachmentsRequest.query('DELETE FROM ticket_attachments WHERE ticket_id = @ticketId');
    logger.success('Attachments deleted');

    // Delete comments
    const deleteCommentsRequest = new sql.Request(transaction);
    deleteCommentsRequest.input('ticketId', sql.Int, ticketId);
    await deleteCommentsRequest.query('DELETE FROM ticket_comments WHERE ticket_id = @ticketId');
    logger.success('Comments deleted');

    // Delete activities
    const deleteActivitiesRequest = new sql.Request(transaction);
    deleteActivitiesRequest.input('ticketId', sql.Int, ticketId);
    await deleteActivitiesRequest.query('DELETE FROM ticket_activities WHERE ticket_id = @ticketId');
    logger.success('Activities deleted');

    // Delete notifications
    const deleteNotificationsRequest = new sql.Request(transaction);
    deleteNotificationsRequest.input('ticketId', sql.Int, ticketId);
    await deleteNotificationsRequest.query('DELETE FROM notifications WHERE related_ticket_id = @ticketId');
    logger.success('Notifications deleted');

    // Delete ticket
    const deleteTicketRequest = new sql.Request(transaction);
    deleteTicketRequest.input('ticketId', sql.Int, ticketId);
    const deleteResult = await deleteTicketRequest.query('DELETE FROM tickets WHERE ticket_id = @ticketId');

    if (deleteResult.rowsAffected[0] === 0) {
      await transaction.rollback();
      logger.error('Failed to delete ticket');
      logger.separator();
      return res.status(500).json(
        createResponse(false, 'Failed to delete ticket')
      );
    }

    logger.success('Ticket deleted from database');

    // Commit transaction
    await transaction.commit();
    logger.success('Transaction committed successfully');

    logger.separator('TICKET DELETED SUCCESSFULLY');
    logger.success('All related data removed', {
      ticketId,
      ticketNumber: ticket.ticket_number,
    });
    logger.separator();

    return res.status(200).json(
      createResponse(true, 'Ticket deleted successfully', {
        deleted_ticket_id: parseInt(ticketId),
        ticket_number: ticket.ticket_number,
        subject: ticket.subject
      })
    );

  } catch (error) {
    if (transaction) {
      try {
        await transaction.rollback();
        logger.warn('Transaction rolled back due to error');
      } catch (rollbackError) {
        logger.error('Rollback error', rollbackError);
      }
    }

    logger.error('Delete ticket error', error);
    logger.separator();
    next(error);
  }
};

// ============================================
// EXPORT ALL FUNCTIONS
// ============================================
module.exports = {
  getTickets,
  getTicketById,
  createTicket,
  updateTicket,
  assignTicket,
  addComment,
  deleteTicket,
};