// ============================================
// NOTIFICATIONS CONTROLLER - FIXED
// Handles notification creation and management
// Developer: Suvadip Panja
// Updated: November 11, 2025 - Added settings checks
// PRODUCTION READY: Now respects notification settings
// ============================================

const { executeQuery, executeProcedure } = require('../config/database');
const { createResponse } = require('../utils/helpers');
const logger = require('../utils/logger');
const settingsService = require('../services/settings.service'); // ⭐ NEW: Import settings service

// ============================================
// HELPER: CHECK IF NOTIFICATION SHOULD BE CREATED
// ⭐ NEW: Validates against system settings
// ============================================
const shouldCreateNotification = async (type) => {
  try {
    // Get notification settings
    const notificationSettings = await settingsService.getByCategory('notification');
    
    // ✅ CHECK 1: Master notification switch
    const masterEnabled = notificationSettings.notification_enabled === 'true' || 
                         notificationSettings.notification_enabled === true;
    
    if (!masterEnabled) {
      logger.info('Notification creation skipped - master switch disabled', { type });
      return false;
    }
    
    // ✅ CHECK 2: Event-specific settings
    const typeMapping = {
      'TICKET_CREATED': 'notification_ticket_created',
      'TICKET_ASSIGNED': 'notification_ticket_assigned',
      'TICKET_COMMENTED': 'notification_ticket_commented',
      'COMMENT_ADDED': 'notification_ticket_commented',
      'STATUS_CHANGED': 'notification_ticket_status_changed',
      'TICKET_UPDATED': 'notification_ticket_status_changed',
      'SLA_WARNING': 'notify_on_sla_warning',
      'SLA_BREACH': 'notify_on_sla_breach',
    };
    
    const settingKey = typeMapping[type];
    
    // If type has specific setting, check it
    if (settingKey) {
      const eventEnabled = notificationSettings[settingKey] === 'true' || 
                          notificationSettings[settingKey] === true;
      
      if (!eventEnabled) {
        logger.info('Notification creation skipped - event disabled', { 
          type, 
          settingKey,
          value: notificationSettings[settingKey]
        });
        return false;
      }
    }
    
    // All checks passed
    logger.success('Notification allowed by settings', { type });
    return true;
    
  } catch (error) {
    logger.error('Error checking notification settings', { type, error });
    // On error, default to allowing notification (fail open)
    return true;
  }
};

// ============================================
// GET NOTIFICATIONS (Paginated)
// @route   GET /api/v1/notifications
// @access  Private
// ============================================
const getNotifications = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const unreadOnly = req.query.unread_only === 'true';
    const offset = (page - 1) * limit;

    logger.try('Fetching notifications', {
      userId,
      page,
      limit,
      unreadOnly,
    });

    // Build WHERE clause
    let whereClause = 'WHERE user_id = @userId';
    if (unreadOnly) {
      whereClause += ' AND is_read = 0';
    }

    // Count total notifications
    const countQuery = `
      SELECT COUNT(*) as total
      FROM notifications
      ${whereClause}
    `;

    const countResult = await executeQuery(countQuery, { userId });
    const totalRecords = countResult.recordset[0].total;
    const totalPages = Math.ceil(totalRecords / limit);

    // Fetch notifications
    const query = `
      SELECT 
        n.notification_id,
        n.user_id,
        n.notification_type,
        n.title,
        n.message,
        n.is_read,
        n.related_ticket_id,
        n.created_at,
        t.ticket_number
      FROM notifications n
      LEFT JOIN tickets t ON n.related_ticket_id = t.ticket_id
      ${whereClause}
      ORDER BY n.created_at DESC
      OFFSET @offset ROWS
      FETCH NEXT @limit ROWS ONLY
    `;

    const result = await executeQuery(query, {
      userId,
      offset,
      limit,
    });

    logger.success('Notifications fetched', {
      userId,
      count: result.recordset.length,
      page,
      totalPages,
    });

    res.json(
      createResponse(true, 'Notifications fetched successfully', {
        notifications: result.recordset,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_records: totalRecords,
          per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1,
        },
      })
    );
  } catch (error) {
    logger.error('Get notifications error', error);
    next(error);
  }
};

// ============================================
// GET UNREAD COUNT
// @route   GET /api/v1/notifications/unread-count
// @access  Private
// ============================================
const getUnreadCount = async (req, res, next) => {
  try {
    const userId = req.user.user_id;

    const query = `
      SELECT COUNT(*) as unread_count
      FROM notifications
      WHERE user_id = @userId AND is_read = 0
    `;

    const result = await executeQuery(query, { userId });
    const unreadCount = result.recordset[0].unread_count;

    res.json(
      createResponse(true, 'Unread count fetched successfully', {
        unread_count: unreadCount,
      })
    );
  } catch (error) {
    logger.error('Get unread count error', error);
    next(error);
  }
};

// ============================================
// MARK AS READ
// @route   PATCH /api/v1/notifications/:id/read
// @access  Private
// ============================================
const markAsRead = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const notificationId = req.params.id;

    logger.try('Marking notification as read', {
      notificationId,
      userId,
    });

    const query = `
      UPDATE notifications
      SET is_read = 1, read_at = GETDATE()
      WHERE notification_id = @notificationId AND user_id = @userId
    `;

    const result = await executeQuery(query, {
      notificationId,
      userId,
    });

    if (result.rowsAffected[0] === 0) {
      return res.status(404).json(
        createResponse(false, 'Notification not found')
      );
    }

    logger.success('Notification marked as read', {
      notificationId,
      userId,
    });

    res.json(createResponse(true, 'Notification marked as read'));
  } catch (error) {
    logger.error('Mark as read error', error);
    next(error);
  }
};

// ============================================
// MARK ALL AS READ
// @route   PATCH /api/v1/notifications/read-all
// @access  Private
// ============================================
const markAllAsRead = async (req, res, next) => {
  try {
    const userId = req.user.user_id;

    logger.try('Marking all notifications as read', { userId });

    const query = `
      UPDATE notifications
      SET is_read = 1, read_at = GETDATE()
      WHERE user_id = @userId AND is_read = 0
    `;

    const result = await executeQuery(query, { userId });

    logger.success('All notifications marked as read', {
      userId,
      count: result.rowsAffected[0],
    });

    res.json(
      createResponse(true, 'All notifications marked as read', {
        updated_count: result.rowsAffected[0],
      })
    );
  } catch (error) {
    logger.error('Mark all as read error', error);
    next(error);
  }
};

// ============================================
// DELETE NOTIFICATION
// @route   DELETE /api/v1/notifications/:id
// @access  Private
// ============================================
const deleteNotification = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const notificationId = req.params.id;

    logger.try('Deleting notification', {
      notificationId,
      userId,
    });

    const query = `
      DELETE FROM notifications
      WHERE notification_id = @notificationId AND user_id = @userId
    `;

    const result = await executeQuery(query, {
      notificationId,
      userId,
    });

    if (result.rowsAffected[0] === 0) {
      return res.status(404).json(
        createResponse(false, 'Notification not found')
      );
    }

    logger.success('Notification deleted', {
      notificationId,
      userId,
    });

    res.json(createResponse(true, 'Notification deleted successfully'));
  } catch (error) {
    logger.error('Delete notification error', error);
    next(error);
  }
};

// ============================================
// CLEAR READ NOTIFICATIONS
// @route   DELETE /api/v1/notifications/clear-read
// @access  Private
// ============================================
const clearReadNotifications = async (req, res, next) => {
  try {
    const userId = req.user.user_id;

    logger.try('Clearing read notifications', { userId });

    const query = `
      DELETE FROM notifications
      WHERE user_id = @userId AND is_read = 1
    `;

    const result = await executeQuery(query, { userId });

    logger.success('Read notifications cleared', {
      userId,
      count: result.rowsAffected[0],
    });

    res.json(
      createResponse(true, 'Read notifications cleared successfully', {
        deleted_count: result.rowsAffected[0],
      })
    );
  } catch (error) {
    logger.error('Clear read notifications error', error);
    next(error);
  }
};

// ============================================
// CREATE NOTIFICATION (UTILITY FUNCTION)
// ⭐ FIXED: Now checks settings before creating
// Used by other controllers
// ============================================
/**
 * Create a notification for a user
 * @param {number} userId - User ID to receive notification
 * @param {string} type - Notification type
 * @param {string} title - Notification title
 * @param {string} message - Notification message
 * @param {number|null} ticketId - Related ticket ID (optional)
 * @returns {Promise<boolean>} - Success status
 */
const createNotification = async (userId, type, title, message, ticketId = null) => {
  try {
    logger.try('Creating notification', {
      userId,
      type,
      ticketId,
    });

    // ⭐ NEW: Check if notification should be created
    const shouldCreate = await shouldCreateNotification(type);
    
    if (!shouldCreate) {
      logger.info('Notification creation skipped due to settings', {
        userId,
        type,
      });
      return false; // Return false but don't throw error
    }

    // Create notification in database
    const query = `
      INSERT INTO notifications (
        user_id, notification_type, title, message, related_ticket_id
      )
      VALUES (@userId, @type, @title, @message, @ticketId)
    `;

    await executeQuery(query, {
      userId,
      type,
      title,
      message,
      ticketId,
    });

    logger.success('Notification created', {
      userId,
      type,
    });

    return true;
  } catch (error) {
    logger.error('Create notification error', error);
    return false; // Return false instead of throwing to prevent breaking caller
  }
};

// ============================================
// CREATE BULK NOTIFICATIONS (UTILITY FUNCTION)
// ⭐ FIXED: Now checks settings before creating
// Used for notifying multiple users
// ============================================
/**
 * Create bulk notifications (for multiple users)
 * @param {Array} userIds - Array of user IDs
 * @param {string} type - Notification type
 * @param {string} title - Notification title
 * @param {string} message - Notification message
 * @param {number|null} ticketId - Related ticket ID (optional)
 * @returns {Promise<Object>} - Result with created count
 */
const createBulkNotifications = async (userIds, type, title, message, ticketId = null) => {
  try {
    logger.try('Creating bulk notifications', {
      userCount: userIds.length,
      type,
      ticketId,
    });

    // ⭐ NEW: Check if notification should be created
    const shouldCreate = await shouldCreateNotification(type);
    
    if (!shouldCreate) {
      logger.info('Bulk notification creation skipped due to settings', {
        userCount: userIds.length,
        type,
      });
      return { success: true, created: 0, skipped: userIds.length };
    }

    // Build values for each user
    const promises = userIds.map((userId) => {
      const query = `
        INSERT INTO notifications (
          user_id, notification_type, title, message, related_ticket_id
        )
        VALUES (@userId, @type, @title, @message, @ticketId)
      `;
      return executeQuery(query, {
        userId,
        type,
        title,
        message,
        ticketId,
      });
    });

    await Promise.all(promises);

    logger.success('Bulk notifications created', {
      count: userIds.length,
      type,
    });

    return { success: true, created: userIds.length, skipped: 0 };
  } catch (error) {
    logger.error('Create bulk notifications error', error);
    return { success: false, created: 0, skipped: userIds.length };
  }
};

// ============================================
// EXPORT ALL FUNCTIONS
// ============================================
module.exports = {
  getNotifications,
  getUnreadCount,
  markAsRead,
  markAllAsRead,
  deleteNotification,
  clearReadNotifications,
  createNotification,
  createBulkNotifications,
};